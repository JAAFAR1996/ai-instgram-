/**
 * ===============================================
 * WhatsApp AI Service
 * AI conversation adaptation for WhatsApp's formal, business-oriented style
 * ===============================================
 */

import { AIService, type ConversationContext, type AIResponse, type MessageHistory } from './ai';
import { getDatabase } from '../database/connection';
import OpenAI from 'openai';

export interface WhatsAppAIResponse extends AIResponse {
  templateSuggestions?: TemplateMessage[];
  businessRecommendations?: BusinessAction[];
  followUpScheduled?: ScheduledMessage;
  complianceFlags?: ComplianceFlag[];
}

export interface TemplateMessage {
  name: string;
  language: string;
  category: 'MARKETING' | 'UTILITY' | 'AUTHENTICATION';
  components: TemplateComponent[];
  useCase: string;
}

export interface TemplateComponent {
  type: 'HEADER' | 'BODY' | 'FOOTER' | 'BUTTONS';
  format?: 'TEXT' | 'IMAGE' | 'VIDEO' | 'DOCUMENT';
  text?: string;
  buttons?: Button[];
}

export interface Button {
  type: 'QUICK_REPLY' | 'URL' | 'PHONE_NUMBER';
  text: string;
  payload?: string;
  url?: string;
  phone_number?: string;
}

export interface BusinessAction {
  type: 'schedule_followup' | 'send_catalog' | 'request_payment' | 'escalate_to_human';
  priority: number;
  data: any;
  executionTime?: Date;
}

export interface ScheduledMessage {
  delay: number; // seconds
  message: string;
  type: 'reminder' | 'followup' | 'promotional';
}

export interface ComplianceFlag {
  type: 'MARKETING' | 'SPAM' | 'PROMOTIONAL' | 'SENSITIVE';
  severity: 'LOW' | 'MEDIUM' | 'HIGH';
  reason: string;
  requiresTemplate: boolean;
}

export interface WhatsAppContext extends ConversationContext {
  messageWindow: 'OPEN' | 'EXPIRED'; // 24-hour window status
  lastUserMessage?: Date;
  businessHours: {
    isOpen: boolean;
    nextOpenTime?: Date;
  };
  qualityRating?: 'GREEN' | 'YELLOW' | 'RED';
}

export class WhatsAppAIService extends AIService {
  private db = getDatabase();

  /**
   * Generate WhatsApp-optimized AI response
   */
  public async generateWhatsAppResponse(
    customerMessage: string,
    context: WhatsAppContext
  ): Promise<WhatsAppAIResponse> {
    const startTime = Date.now();

    try {
      // Get merchant-specific configuration
      const config = await this.getConfigForMerchant(context.merchantId);
      
      // Build WhatsApp-specific prompt
      const prompt = await this.buildWhatsAppConversationPrompt(customerMessage, context);
      
      const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY!,
        timeout: parseInt(process.env.OPENAI_TIMEOUT || '30000'),
      });

      // Call OpenAI with WhatsApp-optimized settings
      const completion = await openai.chat.completions.create({
        model: config.aiModel,
        messages: prompt,
        temperature: 0.7, // More formal than Instagram
        max_tokens: config.maxTokens,
        top_p: 0.9,
        frequency_penalty: 0.1,
        presence_penalty: 0.2,
        response_format: { type: 'json_object' }
      });

      const responseTime = Date.now() - startTime;
      const response = completion.choices[0]?.message?.content;

      if (!response) {
        throw new Error('No response from OpenAI for WhatsApp');
      }

      // Parse WhatsApp AI response
      const aiResponse = JSON.parse(response) as WhatsAppAIResponse;
      
      // Add metadata
      aiResponse.tokens = {
        prompt: completion.usage?.prompt_tokens || 0,
        completion: completion.usage?.completion_tokens || 0,
        total: completion.usage?.total_tokens || 0
      };
      aiResponse.responseTime = responseTime;

      // Add WhatsApp-specific features
      aiResponse.complianceFlags = await this.checkMessageCompliance(
        aiResponse.message, 
        context
      );

      // Check if template is needed (outside 24h window)
      if (context.messageWindow === 'EXPIRED') {
        aiResponse.templateSuggestions = await this.generateTemplateMessages(
          customerMessage,
          context
        );
      }

      // Log WhatsApp AI interaction
      await this.logWhatsAppAIInteraction(context, customerMessage, aiResponse);

      return aiResponse;
    } catch (error) {
      console.error('‚ùå WhatsApp AI response generation failed:', error);
      
      // Get contextual fallback based on WhatsApp context
      const errorType = error.message?.includes('rate limit') ? 'RATE_LIMIT'
                       : error.message?.includes('network') ? 'NETWORK_ERROR'
                       : 'AI_API_ERROR';
      
      return this.getWhatsAppContextualFallback(context, errorType);
    }
  }

  /**
   * Generate template message for users outside 24h window
   */
  public async generateTemplateMessage(
    intent: string,
    merchantId: string,
    variables?: Record<string, string>
  ): Promise<TemplateMessage> {
    try {
      const templates = await this.getApprovedTemplates(merchantId);
      const matchingTemplate = templates.find(t => 
        t.useCase === intent || t.name.includes(intent)
      );

      if (matchingTemplate) {
        return matchingTemplate;
      }

      // Generate new template suggestion
      return {
        name: `${intent}_response`,
        language: 'ar',
        category: 'UTILITY',
        components: [
          {
            type: 'BODY',
            text: await this.generateTemplateText(intent, merchantId)
          }
        ],
        useCase: intent
      };
    } catch (error) {
      console.error('‚ùå Template generation failed:', error);
      return this.getDefaultTemplate(intent);
    }
  }

  /**
   * Check if customer can receive promotional messages
   */
  public async canSendPromotionalMessage(
    customerPhone: string,
    merchantId: string
  ): Promise<{
    canSend: boolean;
    reason?: string;
    requiresTemplate: boolean;
    lastMessageTime?: Date;
  }> {
    try {
      const sql = this.db.getSQL();
      
      const result = await sql`
        SELECT 
          last_message_at,
          opt_in_status,
          message_window_status
        FROM conversations
        WHERE customer_phone = ${customerPhone}
        AND merchant_id = ${merchantId}::uuid
        ORDER BY last_message_at DESC
        LIMIT 1
      `;

      if (result.length === 0) {
        return {
          canSend: false,
          reason: 'No previous conversation',
          requiresTemplate: true
        };
      }

      const conversation = result[0];
      const lastMessageTime = new Date(conversation.last_message_at);
      const hoursSinceLastMessage = 
        (Date.now() - lastMessageTime.getTime()) / (1000 * 60 * 60);

      const withinWindow = hoursSinceLastMessage < 24;

      return {
        canSend: withinWindow || conversation.opt_in_status === 'OPTED_IN',
        reason: withinWindow ? 'Within 24h window' : 'Outside window',
        requiresTemplate: !withinWindow && conversation.opt_in_status !== 'OPTED_IN',
        lastMessageTime
      };
    } catch (error) {
      console.error('‚ùå Failed to check promotional message permission:', error);
      return {
        canSend: false,
        reason: 'Error checking permissions',
        requiresTemplate: true
      };
    }
  }

  /**
   * Schedule follow-up message
   */
  public async scheduleFollowUp(
    customerPhone: string,
    merchantId: string,
    message: string,
    delayHours: number = 24
  ): Promise<boolean> {
    try {
      const sql = this.db.getSQL();
      
      await sql`
        INSERT INTO scheduled_messages (
          merchant_id,
          customer_phone,
          message_content,
          scheduled_for,
          message_type,
          platform,
          status
        ) VALUES (
          ${merchantId}::uuid,
          ${customerPhone},
          ${message},
          NOW() + INTERVAL '${delayHours} hours',
          'followup',
          'WHATSAPP',
          'pending'
        )
      `;

      console.log(`‚úÖ Follow-up scheduled for ${customerPhone} in ${delayHours}h`);
      return true;
    } catch (error) {
      console.error('‚ùå Failed to schedule follow-up:', error);
      return false;
    }
  }

  /**
   * Get merchant-specific AI configuration
   */
  private async getConfigForMerchant(merchantId: string): Promise<{
    aiModel: string;
    maxTokens: number;
    temperature: number;
    language: string;
  }> {
    try {
      const sql = this.db.getSQL();
      const result = await sql`
        SELECT ai_config 
        FROM merchants 
        WHERE id = ${merchantId}::uuid
      `;
      
      if (result.length > 0 && result[0].ai_config) {
        return {
          aiModel: result[0].ai_config.model || 'gpt-4o-mini',
          maxTokens: result[0].ai_config.maxTokens || 800,
          temperature: result[0].ai_config.temperature || 0.7,
          language: result[0].ai_config.language || 'ar'
        };
      }
      
      // Default configuration
      return {
        aiModel: process.env.OPENAI_MODEL || 'gpt-4o-mini',
        maxTokens: parseInt(process.env.OPENAI_MAX_TOKENS || '800'),
        temperature: 0.7,
        language: 'ar'
      };
    } catch (error) {
      console.error('‚ùå Error loading merchant config:', error);
      return {
        aiModel: 'gpt-4o-mini',
        maxTokens: 800,
        temperature: 0.7,
        language: 'ar'
      };
    }
  }

  /**
   * Get WhatsApp contextual fallback
   */
  private getWhatsAppContextualFallback(
    context: WhatsAppContext, 
    errorType: string
  ): WhatsAppAIResponse {
    const fallbacks = {
      'RATE_LIMIT': context.messageWindow === 'EXPIRED'
        ? 'ÿ¥ŸÉÿ±ÿßŸã ŸÑÿ™ŸàÿßÿµŸÑŸÉ ŸÖÿπŸÜÿß. ÿ≥ŸÜÿ±ÿØ ÿπŸÑŸäŸÉ ÿÆŸÑÿßŸÑ ÿ≥ÿßÿπÿßÿ™ ÿßŸÑÿπŸÖŸÑ. üïê'
        : 'ÿ¥ŸÉÿ±ÿßŸã ŸÑÿµÿ®ÿ±ŸÉ. ŸÜÿ≠ŸÜ ŸÜÿπŸÖŸÑ ÿπŸÑŸâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±ÿßÿ™ ÿ®ÿ£ÿ≥ÿ±ÿπ ŸàŸÇÿ™ ŸÖŸÖŸÉŸÜ.',
      
      'AI_API_ERROR': context.businessHours.isOpen
        ? 'ŸÜÿπÿ™ÿ∞ÿ± ÿπŸÜ ÿßŸÑÿ™ÿ£ÿÆŸäÿ±. ŸÅÿ±ŸäŸÇ ÿÆÿØŸÖÿ© ÿßŸÑÿπŸÖŸÑÿßÿ° ÿ≥Ÿäÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÉ ÿÆŸÑÿßŸÑ ÿØŸÇÿßÿ¶ŸÇ.'
        : 'ÿ¥ŸÉÿ±ÿßŸã ŸÑÿ™ŸàÿßÿµŸÑŸÉ ŸÖÿπŸÜÿß ÿÆÿßÿ±ÿ¨ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿπŸÖŸÑ. ÿ≥ŸÜÿ±ÿØ ÿπŸÑŸäŸÉ ŸÅŸä ÿ£ŸÇÿ±ÿ® ŸÅÿ±ÿµÿ© ÿÆŸÑÿßŸÑ ÿ≥ÿßÿπÿßÿ™ ÿßŸÑÿπŸÖŸÑ.',
      
      'NETWORK_ERROR': 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ™ŸÇŸÜŸä ŸÖÿ§ŸÇÿ™. Ÿäÿ±ÿ¨Ÿâ ÿ•ÿπÿßÿØÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿÆŸÑÿßŸÑ ÿØŸÇÿßÿ¶ŸÇ ŸÇŸÑŸäŸÑÿ©.'
    };

    const message = fallbacks[errorType] || fallbacks['AI_API_ERROR'];

    return {
      message,
      messageAr: message,
      intent: 'SUPPORT',
      stage: context.stage,
      actions: [{ 
        type: context.messageWindow === 'EXPIRED' ? 'SCHEDULE_TEMPLATE' : 'ESCALATE', 
        data: { reason: errorType }, 
        priority: 1 
      }],
      products: [],
      confidence: 0.1,
      tokens: { prompt: 0, completion: 0, total: 0 },
      responseTime: 0,
      complianceFlags: [],
      templateSuggestions: context.messageWindow === 'EXPIRED' 
        ? [this.getDefaultTemplate('error')] 
        : undefined
    };
  }

  /**
   * Build WhatsApp-specific conversation prompt
   */
  private async buildWhatsAppConversationPrompt(
    customerMessage: string,
    context: WhatsAppContext
  ): Promise<OpenAI.Chat.Completions.ChatCompletionMessageParam[]> {
    const systemPrompt = `ÿ£ŸÜÿ™ ŸÖÿ≥ÿßÿπÿØ ŸÖÿ®Ÿäÿπÿßÿ™ ÿ∞ŸÉŸä ŸÖÿ™ÿÆÿµÿµ ŸÅŸä WhatsApp Business ŸÑŸÑÿ™ÿ¨ÿßÿ± ÿßŸÑÿπÿ±ÿßŸÇŸäŸäŸÜ.

üè¢ ÿÆÿµÿßÿ¶ÿµ ÿ£ÿ≥ŸÑŸàÿ® WhatsApp Business:
- ÿ£ÿ≥ŸÑŸàÿ® ŸÖŸáŸÜŸä ŸàŸàÿØŸàÿØ
- ÿ±ÿØŸàÿØ ŸÖŸÜÿ∏ŸÖÿ© ŸàŸÖŸÅŸäÿØÿ©
- ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿ≠ÿØŸàÿØ ŸÑŸÑÿ±ŸÖŸàÿ≤ ÿßŸÑÿ™ÿπÿ®Ÿäÿ±Ÿäÿ© (1-2 ŸÅŸÇÿ∑)
- ÿ™ÿ±ŸÉŸäÿ≤ ÿπŸÑŸâ ÿßŸÑŸàÿ∂Ÿàÿ≠ ŸàÿßŸÑŸÅÿßÿ¶ÿØÿ©
- ÿßÿ≠ÿ™ÿ±ÿßŸÖ ŸÜÿßŸÅÿ∞ÿ© ÿßŸÑŸÄ 24 ÿ≥ÿßÿπÿ©
- ÿßŸÑÿ™ÿ≤ÿßŸÖ ÿ®ÿ≥Ÿäÿßÿ≥ÿßÿ™ WhatsApp Business

üì± ÿ≠ÿßŸÑÿ© ÿßŸÑŸÜÿßŸÅÿ∞ÿ©: ${context.messageWindow === 'OPEN' ? 'ŸÖŸÅÿ™Ÿàÿ≠ÿ© (ŸäŸÖŸÉŸÜ ÿßŸÑÿ±ÿØ ŸÖÿ®ÿßÿ¥ÿ±ÿ©)' : 'ŸÖŸÜÿ™ŸáŸäÿ© (Ÿäÿ≠ÿ™ÿßÿ¨ template)'}
üè™ ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≠ŸÑ: ${context.merchantSettings?.businessName || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}
üõçÔ∏è ŸÅÿ¶ÿ© ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™: ${context.merchantSettings?.businessCategory || 'ÿπÿßŸÖ'}
‚è∞ ÿ≥ÿßÿπÿßÿ™ ÿßŸÑÿπŸÖŸÑ: ${context.businessHours.isOpen ? 'ŸÖŸÅÿ™Ÿàÿ≠ ÿ≠ÿßŸÑŸäÿßŸã' : 'ŸÖÿ∫ŸÑŸÇ'}
üìä ÿ¨ŸàÿØÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®: ${context.qualityRating || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}

üéØ ÿ•ÿ±ÿ¥ÿßÿØÿßÿ™ WhatsApp:
1. ŸÉŸÜ ŸÖŸáŸÜŸäÿßŸã ŸàŸÖÿ®ÿßÿ¥ÿ±ÿßŸã
2. ÿßÿπÿ±ÿ∂ ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿ®Ÿàÿ∂Ÿàÿ≠ ŸÖÿπ ÿßŸÑÿ£ÿ≥ÿπÿßÿ±
3. ÿßÿ∑ŸÑÿ® ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÑŸÑÿ∑ŸÑÿ® (ÿßŸÑÿßÿ≥ŸÖÿå ÿßŸÑÿπŸÜŸàÿßŸÜÿå ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ)
4. ÿßŸÇÿ™ÿ±ÿ≠ ÿ∑ÿ±ŸÇ ÿßŸÑÿØŸÅÿπ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©
5. ÿ£ŸÉÿØ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ∑ŸÑÿ® ŸÇÿ®ŸÑ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ
6. ÿßÿ≠ÿ™ÿ±ŸÖ ÿÆÿµŸàÿµŸäÿ© ÿßŸÑÿπŸÖŸäŸÑ
7. ŸÑÿß ÿ™ÿ≥ÿ£ŸÑ ÿπŸÜ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ≠ÿ≥ÿßÿ≥ÿ© ÿ∫Ÿäÿ± ÿ∂ÿ±Ÿàÿ±Ÿäÿ©

‚ö†Ô∏è ŸÇŸäŸàÿØ ŸÖŸáŸÖÿ©:
- ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÜÿßŸÅÿ∞ÿ© ŸÖŸÜÿ™ŸáŸäÿ©ÿå ÿßŸÇÿ™ÿ±ÿ≠ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ template message
- ŸÑÿß ÿ™ÿ±ÿ≥ŸÑ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿ™ÿ±ŸàŸäÿ¨Ÿäÿ© ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÜÿßŸÅÿ∞ÿ©
- ÿ™ÿ¨ŸÜÿ® spam ÿ£Ÿà ÿ±ÿ≥ÿßÿ¶ŸÑ ŸÖÿ™ŸÉÿ±ÿ±ÿ©
- ÿßÿ≠ÿ™ÿ±ŸÖ ÿ±ŸÅÿ∂ ÿßŸÑÿπŸÖŸäŸÑ

üéØ Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿ•ÿ¨ÿßÿ®ÿ™ŸÉ ÿ®ÿµŸäÿ∫ÿ© JSON:
{
  "message": "ÿßŸÑÿ±ÿØ ÿßŸÑŸÖŸáŸÜŸä ŸÑWhatsApp",
  "messageAr": "ŸÜŸÅÿ≥ ÿßŸÑÿ±ÿØ",
  "intent": "ŸÜŸäÿ© ÿßŸÑÿπŸÖŸäŸÑ",
  "stage": "ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©",
  "actions": [{"type": "ŸÜŸàÿπ ÿßŸÑÿπŸÖŸÑ", "data": {}, "priority": 1}],
  "products": [{"productId": "", "sku": "", "name": "", "price": 0, "confidence": 0.8, "reason": ""}],
  "confidence": 0.9,
  "businessRecommendations": [
    {
      "type": "schedule_followup|send_catalog|request_payment",
      "priority": 1,
      "data": {},
      "executionTime": "2024-01-01T10:00:00Z"
    }
  ]
}`;

    const messages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
      { role: 'system', content: systemPrompt }
    ];

    // Add conversation history (more formal context for WhatsApp)
    context.conversationHistory.slice(-6).forEach(msg => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });

    // Add current customer message with WhatsApp context
    let messageWithContext = customerMessage;
    if (context.messageWindow === 'EXPIRED') {
      messageWithContext = `[ÿÆÿßÿ±ÿ¨ ŸÜÿßŸÅÿ∞ÿ© 24 ÿ≥ÿßÿπÿ©] ${customerMessage}`;
    }
    if (!context.businessHours.isOpen) {
      messageWithContext = `[ÿÆÿßÿ±ÿ¨ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿπŸÖŸÑ] ${messageWithContext}`;
    }

    messages.push({
      role: 'user',
      content: messageWithContext
    });

    return messages;
  }

  /**
   * Check message compliance with WhatsApp policies
   */
  private async checkMessageCompliance(
    message: string,
    context: WhatsAppContext
  ): Promise<ComplianceFlag[]> {
    const flags: ComplianceFlag[] = [];

    // Check for promotional content outside window
    const promotionalKeywords = ['ÿπÿ±ÿ∂', 'ÿÆÿµŸÖ', 'ÿ™ÿÆŸÅŸäÿ∂', 'ŸÖÿ¨ÿßŸÜŸä', 'ŸáÿØŸäÿ©'];
    const hasPromotional = promotionalKeywords.some(word => message.includes(word));
    
    if (hasPromotional && context.messageWindow === 'EXPIRED') {
      flags.push({
        type: 'PROMOTIONAL',
        severity: 'HIGH',
        reason: 'Promotional content outside 24h window',
        requiresTemplate: true
      });
    }

    // Check message length (WhatsApp has limits)
    if (message.length > 4000) {
      flags.push({
        type: 'SPAM',
        severity: 'MEDIUM',
        reason: 'Message too long',
        requiresTemplate: false
      });
    }

    // Check for sensitive content
    const sensitiveKeywords = ['ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ±', 'ÿ±ŸÇŸÖ ÿ≥ÿ±Ÿä', 'ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ®ŸÜŸÉ'];
    if (sensitiveKeywords.some(word => message.includes(word))) {
      flags.push({
        type: 'SENSITIVE',
        severity: 'HIGH',
        reason: 'Contains sensitive information request',
        requiresTemplate: false
      });
    }

    return flags;
  }

  /**
   * Get approved templates for merchant
   */
  private async getApprovedTemplates(merchantId: string): Promise<TemplateMessage[]> {
    try {
      const sql = this.db.getSQL();
      
      const result = await sql`
        SELECT template_data
        FROM whatsapp_templates
        WHERE merchant_id = ${merchantId}::uuid
        AND status = 'APPROVED'
      `;

      return result.map(row => JSON.parse(row.template_data));
    } catch (error) {
      console.error('‚ùå Error loading templates:', error);
      return [];
    }
  }

  /**
   * Generate template text for specific intent
   */
  private async generateTemplateText(intent: string, merchantId: string): Promise<string> {
    const templates = {
      'greeting': 'ŸÖÿ±ÿ≠ÿ®ÿßŸã {{1}}! ÿ¥ŸÉÿ±ÿßŸã ŸÑÿ™ŸàÿßÿµŸÑŸÉ ŸÖÿπ {{2}}. ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜÿß ŸÖÿ≥ÿßÿπÿØÿ™ŸÉÿü',
      'product_inquiry': 'ŸÖÿ±ÿ≠ÿ®ÿßŸã! ŸÜÿ¥ŸÉÿ±ŸÉ ÿπŸÑŸâ ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±ŸÉ ÿπŸÜ ŸÖŸÜÿ™ÿ¨ÿßÿ™ŸÜÿß. ÿ™ŸÅÿ∂ŸÑ ÿ®ÿ≤Ÿäÿßÿ±ÿ© ŸÖÿ™ÿ¨ÿ±ŸÜÿß ÿ£Ÿà ÿ±ÿßÿ≥ŸÑŸÜÿß ŸÑŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ.',
      'order_confirmation': 'ÿ¥ŸÉÿ±ÿßŸã ŸÑÿ∑ŸÑÿ®ŸÉ! ÿ≥ŸÜÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÉ ŸÇÿ±Ÿäÿ®ÿßŸã ŸÑÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ ŸàÿßŸÑÿ™ŸàÿµŸäŸÑ.',
      'support': 'ŸÜÿ≠ŸÜ ŸáŸÜÿß ŸÑŸÖÿ≥ÿßÿπÿØÿ™ŸÉ! Ÿäÿ±ÿ¨Ÿâ ŸàÿµŸÅ ŸÖÿ¥ŸÉŸÑÿ™ŸÉ Ÿàÿ≥ŸÜÿ¨ÿØ ÿßŸÑÿ≠ŸÑ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®.',
      'error': 'ŸÜÿπÿ™ÿ∞ÿ± ÿπŸÜ ÿ£Ÿä ÿ•ÿ≤ÿπÿßÿ¨. ŸÅÿ±ŸäŸÇ ÿÆÿØŸÖÿ© ÿßŸÑÿπŸÖŸÑÿßÿ° ÿ≥Ÿäÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÉ ŸÇÿ±Ÿäÿ®ÿßŸã ŸÑÿ≠ŸÑ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©.'
    };

    return templates[intent] || templates['greeting'];
  }

  /**
   * Get default template for error cases
   */
  private getDefaultTemplate(intent: string): TemplateMessage {
    return {
      name: `${intent}_default`,
      language: 'ar',
      category: 'UTILITY',
      components: [
        {
          type: 'BODY',
          text: 'ÿ¥ŸÉÿ±ÿßŸã ŸÑÿ™ŸàÿßÿµŸÑŸÉ ŸÖÿπŸÜÿß. ÿ≥ŸÜÿ±ÿØ ÿπŸÑŸäŸÉ ŸÅŸä ÿ£ŸÇÿ±ÿ® ŸàŸÇÿ™ ŸÖŸÖŸÉŸÜ.'
        }
      ],
      useCase: intent
    };
  }

  /**
   * Log WhatsApp AI interaction
   */
  private async logWhatsAppAIInteraction(
    context: WhatsAppContext,
    input: string,
    response: WhatsAppAIResponse
  ): Promise<void> {
    try {
      const sql = this.db.getSQL();
      
      await sql`
        INSERT INTO audit_logs (
          merchant_id,
          action,
          entity_type,
          details,
          execution_time_ms,
          success
        ) VALUES (
          ${context.merchantId}::uuid,
          'WHATSAPP_AI_RESPONSE_GENERATED',
          'AI_INTERACTION',
          ${JSON.stringify({
            input: input.substring(0, 200),
            intent: response.intent,
            stage: response.stage,
            tokens: response.tokens,
            confidence: response.confidence,
            platform: 'WHATSAPP',
            messageWindow: context.messageWindow,
            businessHours: context.businessHours.isOpen,
            complianceFlags: response.complianceFlags?.length || 0,
            templateSuggested: response.templateSuggestions?.length || 0
          })},
          ${response.responseTime},
          true
        )
      `;
    } catch (error) {
      console.error('‚ùå WhatsApp AI interaction logging failed:', error);
    }
  }
}

// Singleton instance
let whatsappAIServiceInstance: WhatsAppAIService | null = null;

/**
 * Get WhatsApp AI service instance
 */
export function getWhatsAppAIService(): WhatsAppAIService {
  if (!whatsappAIServiceInstance) {
    whatsappAIServiceInstance = new WhatsAppAIService();
  }
  return whatsappAIServiceInstance;
}

export default WhatsAppAIService;