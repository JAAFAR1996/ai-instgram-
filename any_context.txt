src/cache/index.ts-63-        this.stats.misses++;
src/cache/index.ts-64-        return null;
src/cache/index.ts-65-      }
src/cache/index.ts:66:    } catch (error: any) {
src/cache/index.ts-67-      this.stats.errors++;
src/cache/index.ts-68-      log.warn('Cache get failed, falling back to null', {
src/cache/index.ts-69-        key: fullKey,
--
src/cache/index.ts-102-        });
src/cache/index.ts-103-        return false;
src/cache/index.ts-104-      }
src/cache/index.ts:105:    } catch (error: any) {
src/cache/index.ts-106-      this.stats.errors++;
src/cache/index.ts-107-      log.warn('Cache set failed', {
src/cache/index.ts-108-        key: fullKey,
--
src/cache/index.ts-134-      } else {
src/cache/index.ts-135-        return false;
src/cache/index.ts-136-      }
src/cache/index.ts:137:    } catch (error: any) {
src/cache/index.ts-138-      this.stats.errors++;
src/cache/index.ts-139-      log.warn('Cache delete failed', {
src/cache/index.ts-140-        key: fullKey,
--
src/cache/index.ts-161-      );
src/cache/index.ts-162-
src/cache/index.ts-163-      return result.ok ? (result.result || false) : false;
src/cache/index.ts:164:    } catch (error: any) {
src/cache/index.ts-165-      this.stats.errors++;
src/cache/index.ts-166-      log.warn('Cache exists check failed', {
src/cache/index.ts-167-        key: fullKey,
--
src/cache/index.ts-196-        this.stats.misses += keys.length;
src/cache/index.ts-197-        return keys.map(() => null);
src/cache/index.ts-198-      }
src/cache/index.ts:199:    } catch (error: any) {
src/cache/index.ts-200-      this.stats.errors++;
src/cache/index.ts-201-      log.warn('Cache mget failed', {
src/cache/index.ts-202-        keys: fullKeys,
--
src/cache/index.ts-236-      } else {
src/cache/index.ts-237-        return false;
src/cache/index.ts-238-      }
src/cache/index.ts:239:    } catch (error: any) {
src/cache/index.ts-240-      this.stats.errors++;
src/cache/index.ts-241-      log.warn('Cache mset failed', {
src/cache/index.ts-242-        count: entries.length,
--
src/cache/index.ts-311-    return this.get(`template:${merchantId}:${templateId}`, { prefix: 'templates' });
src/cache/index.ts-312-  }
src/cache/index.ts-313-
src/cache/index.ts:314:  async setTemplate(merchantId: string, templateId: string, template: any): Promise<boolean> {
src/cache/index.ts-315-    return this.set(`template:${merchantId}:${templateId}`, template, { prefix: 'templates' });
src/cache/index.ts-316-  }
src/cache/index.ts-317-
--
src/cache/index.ts-329-    return this.get(`session:${sessionId}`, { prefix: 'sessions' });
src/cache/index.ts-330-  }
src/cache/index.ts-331-
src/cache/index.ts:332:  async setSession(sessionId: string, sessionData: any): Promise<boolean> {
src/cache/index.ts-333-    return this.set(`session:${sessionId}`, sessionData, { prefix: 'sessions' });
src/cache/index.ts-334-  }
src/cache/index.ts-335-
--
src/container/index.ts-28-  sessionCache: SessionCache;
src/container/index.ts-29-
src/container/index.ts-30-  // Business services (will be populated)
src/container/index.ts:31:  aiService?: any;
src/container/index.ts:32:  instagramService?: any;
src/container/index.ts:33:  webhookService?: any;
src/container/index.ts:34:  utilityMessagesService?: any;
src/container/index.ts-35-}
src/container/index.ts-36-
src/container/index.ts-37-/**
--
src/container/index.ts-69-      this.services.sessionCache = getSessionCache();
src/container/index.ts-70-
src/container/index.ts-71-      log.info('Core services initialized in DI container');
src/container/index.ts:72:    } catch (error: any) {
src/container/index.ts-73-      log.error('Failed to initialize core services:', error);
src/container/index.ts-74-      throw error;
src/container/index.ts-75-    }
--
src/container/index.ts-119-      try {
src/container/index.ts-120-        registration.instance = registration.factory();
src/container/index.ts-121-        log.debug(`Singleton created: ${key}`);
src/container/index.ts:122:      } catch (error: any) {
src/container/index.ts-123-        log.error(`Failed to create singleton ${key}:`, error);
src/container/index.ts-124-        throw error;
src/container/index.ts-125-      }
--
src/container/index.ts-198-          await (service as Pool).query('SELECT 1');
src/container/index.ts-199-        }
src/container/index.ts-200-        results.push({ name, status: 'healthy' as const });
src/container/index.ts:201:      } catch (error: any) {
src/container/index.ts-202-        results.push({ 
src/container/index.ts-203-          name, 
src/container/index.ts-204-          status: 'error' as const, 
--
src/container/index.ts-217- * Service decorator for automatic registration
src/container/index.ts-218- */
src/container/index.ts-219-export function Service(name?: string) {
src/container/index.ts:220:  return function <T extends { new (...args: any[]): {} }>(constructor: T) {
src/container/index.ts-221-    const serviceName = name || constructor.name;
src/container/index.ts-222-    const container = DIContainer.getInstance();
src/container/index.ts-223-    
--
src/container/index.ts-233- * Inject decorator for dependency injection
src/container/index.ts-234- */
src/container/index.ts-235-export function Inject(token: string) {
src/container/index.ts:236:  return function (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
src/container/index.ts-237-    // Store metadata for dependency injection
src/container/index.ts:238:    const existingTokens = (Reflect as any).getMetadata?.('inject-tokens', target) || [];
src/container/index.ts-239-    existingTokens[parameterIndex] = token;
src/container/index.ts:240:    (Reflect as any).defineMetadata?.('inject-tokens', existingTokens, target);
src/container/index.ts-241-  };
src/container/index.ts-242-}
src/container/index.ts-243-
--
src/bootstrap/logging.ts-21-
src/bootstrap/logging.ts-22-    const write = 
src/bootstrap/logging.ts-23-      (lvl: 'info' | 'warn' | 'error' | 'debug') =>
src/bootstrap/logging.ts:24:        (...args: any[]) => {
src/bootstrap/logging.ts-25-          const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
src/bootstrap/logging.ts-26-          try {
src/bootstrap/logging.ts-27-            if (lvl === 'info') base.info(msg);
--
src/isolation/context.ts-3-import { z } from 'zod';
src/isolation/context.ts-4-
src/isolation/context.ts-5-// Error serialization helper
src/isolation/context.ts:6:export function serr(e: any) {
src/isolation/context.ts-7-  return { 
src/isolation/context.ts-8-    name: e?.name, 
src/isolation/context.ts-9-    message: e?.message, 
--
src/isolation/context.ts-52-export async function withDbTenant<T>(
src/isolation/context.ts-53-  pool: Pool,
src/isolation/context.ts-54-  merchantId: string,
src/isolation/context.ts:55:  fn: (client: any) => Promise<T>
src/isolation/context.ts-56-): Promise<T> {
src/isolation/context.ts-57-  if (!merchantId) {
src/isolation/context.ts-58-    throw new Error('MISSING_MERCHANT_ID');
--
src/isolation/context.ts-95-// Worker job wrapper with tenant isolation
src/isolation/context.ts-96-export function withTenantJob<T>(
src/isolation/context.ts-97-  pool: Pool,
src/isolation/context.ts:98:  logger: any,
src/isolation/context.ts:99:  handler: (job: any, data: JobData, client: any) => Promise<T>
src/isolation/context.ts-100-) {
src/isolation/context.ts:101:  return async (job: any) => {
src/isolation/context.ts-102-    try {
src/isolation/context.ts-103-      // Validate job data schema
src/isolation/context.ts-104-      const data = JobSchema.parse(job.data);
--
src/isolation/context.ts-155-// Webhook-specific tenant job wrapper
src/isolation/context.ts-156-export function withWebhookTenantJob<T>(
src/isolation/context.ts-157-  pool: Pool,
src/isolation/context.ts:158:  logger: any,
src/isolation/context.ts:159:  handler: (job: any, data: WebhookJobData, client: any) => Promise<T>
src/isolation/context.ts-160-) {
src/isolation/context.ts:161:  return async (job: any) => {
src/isolation/context.ts-162-    try {
src/isolation/context.ts-163-      // Validate webhook job data schema
src/isolation/context.ts-164-      const data = WebhookJobSchema.parse(job.data);
--
src/isolation/context.ts-185-// AI-specific tenant job wrapper
src/isolation/context.ts-186-export function withAITenantJob<T>(
src/isolation/context.ts-187-  pool: Pool,
src/isolation/context.ts:188:  logger: any,
src/isolation/context.ts:189:  handler: (job: any, data: AIJobData, client: any) => Promise<T>
src/isolation/context.ts-190-) {
src/isolation/context.ts:191:  return async (job: any) => {
src/isolation/context.ts-192-    try {
src/isolation/context.ts-193-      // Validate AI job data schema
src/isolation/context.ts-194-      const data = AIJobSchema.parse(job.data);
--
src/isolation/context.ts-213-}
src/isolation/context.ts-214-
src/isolation/context.ts-215-// Common error handler for tenant jobs
src/isolation/context.ts:216:async function handleTenantJobError(error: any, job: any, logger: any) {
src/isolation/context.ts-217-  if (error instanceof z.ZodError) {
src/isolation/context.ts-218-    const validationError = new Error('INVALID_JOB_DATA');
src/isolation/context.ts-219-    logger.error({
--
src/api/webhooks.ts-168-  /**
src/api/webhooks.ts-169-   * Handle Instagram webhook verification (GET request)
src/api/webhooks.ts-170-   */
src/api/webhooks.ts:171:  private async handleInstagramVerification(c: any) {
src/api/webhooks.ts-172-    try {
src/api/webhooks.ts-173-      this.logger.info('Instagram webhook verification request received');
src/api/webhooks.ts-174-      
--
src/api/webhooks.ts-207-  /**
src/api/webhooks.ts-208-   * Handle Instagram webhook events (POST request)
src/api/webhooks.ts-209-   */
src/api/webhooks.ts:210:  private async handleInstagramWebhook(c: any) {
src/api/webhooks.ts-211-    let merchantId: string | undefined;
src/api/webhooks.ts-212-    try {
src/api/webhooks.ts-213-      this.logger.info('Instagram webhook event received');
--
src/api/webhooks.ts-401-  /**
src/api/webhooks.ts-402-   * Process Instagram webhook entry
src/api/webhooks.ts-403-   */
src/api/webhooks.ts:404:  private async processInstagramEntry(entry: any): Promise<void> {
src/api/webhooks.ts-405-    try {
src/api/webhooks.ts-406-      // Get merchant ID from entry ID (Page ID)
src/api/webhooks.ts-407-      const pageId = entry.id;
--
src/api/webhooks.ts-467-  /**
src/api/webhooks.ts-468-   * Process WhatsApp webhook entry - DISABLED
src/api/webhooks.ts-469-   */
src/api/webhooks.ts:470:  private async processWhatsAppEntry(entry: any): Promise<void> {
src/api/webhooks.ts-471-    this.logger.info('WhatsApp processing disabled - entry ignored');
src/api/webhooks.ts-472-    await this.logWebhookEvent('whatsapp', 'disabled', 'ERROR', {
src/api/webhooks.ts-473-      error: 'WhatsApp features are disabled'
--
src/api/webhooks.ts-555-    platform: 'instagram' | 'whatsapp',
src/api/webhooks.ts-556-    merchantId: string,
src/api/webhooks.ts-557-    status: 'SUCCESS' | 'ERROR',
src/api/webhooks.ts:558:    details: any
src/api/webhooks.ts-559-  ): Promise<void> {
src/api/webhooks.ts-560-    try {
src/api/webhooks.ts-561-      const sql = this.db.getSQL();
--
src/api/webhooks.ts-586-  /**
src/api/webhooks.ts-587-   * Generate hash for merchant and body (idempotency)
src/api/webhooks.ts-588-   */
src/api/webhooks.ts:589:  private generateMerchantBodyHash(merchantId: string, body: any): string {
src/api/webhooks.ts-590-    const content = `${merchantId}:${JSON.stringify(body)}`;
src/api/webhooks.ts-591-    return crypto.createHash('sha256').update(content).digest('hex');
src/api/webhooks.ts-592-  }
--
src/api/webhooks.ts-596-   */
src/api/webhooks.ts-597-  private async checkWebhookIdempotency(
src/api/webhooks.ts-598-    merchantId: string, 
src/api/webhooks.ts:599:    body: any,
src/api/webhooks.ts-600-    platform: 'instagram' | 'whatsapp'
src/api/webhooks.ts-601-  ): Promise<{ isDuplicate: boolean; eventId: string }> {
src/api/webhooks.ts-602-    const eventId = this.generateMerchantBodyHash(merchantId, body);
--
src/repos/unit-of-work.ts-62-        }
src/repos/unit-of-work.ts-63-        
src/repos/unit-of-work.ts-64-        return result;
src/repos/unit-of-work.ts:65:      } catch (error: any) {
src/repos/unit-of-work.ts-66-        if (!rolledBack) {
src/repos/unit-of-work.ts-67-          log.error('Transaction failed, rolling back:', error);
src/repos/unit-of-work.ts-68-        }
--
src/db/adapter.ts-46-      console.debug(`Query executed in ${duration}ms, ${result.rows.length} rows returned`);
src/db/adapter.ts-47-      
src/db/adapter.ts-48-      return result.rows as T[];
src/db/adapter.ts:49:    } catch (error: any) {
src/db/adapter.ts-50-      throw new DatabaseError(
src/db/adapter.ts-51-        error.message,
src/db/adapter.ts-52-        error.code,
--
src/db/adapter.ts-82-      console.debug('Transaction committed');
src/db/adapter.ts-83-      
src/db/adapter.ts-84-      return result;
src/db/adapter.ts:85:    } catch (error: any) {
src/db/adapter.ts-86-      await client.query('ROLLBACK');
src/db/adapter.ts-87-      console.debug('Transaction rolled back');
src/db/adapter.ts-88-      
--
src/db/adapter.ts-116-  async close(): Promise<void> {
src/db/adapter.ts-117-    try {
src/db/adapter.ts-118-      await this.pool.end();
src/db/adapter.ts:119:    } catch (error: any) {
src/db/adapter.ts-120-      throw new DatabaseError(
src/db/adapter.ts-121-        `Failed to close database: ${error.message}`,
src/db/adapter.ts-122-        error.code
--
src/api/service-control.test.ts-19-mock.module('../middleware/security.js', () => {
src/api/service-control.test.ts-20-  const limiter = new RateLimiterMemory({ points: 10, duration: 60 });
src/api/service-control.test.ts-21-  return {
src/api/service-control.test.ts:22:    securityHeaders: async (_c: any, next: any) => {
src/api/service-control.test.ts-23-      await next();
src/api/service-control.test.ts-24-    },
src/api/service-control.test.ts:25:    rateLimiter: async (c: any, next: any) => {
src/api/service-control.test.ts-26-      const key = c.req.header('x-rate-key') || 'test-key';
src/api/service-control.test.ts-27-      try {
src/api/service-control.test.ts-28-        await limiter.consume(key);
--
src/api/service-control.test.ts-49-const TEST_USER_ID = 'test-admin-user';
src/api/service-control.test.ts-50-
src/api/service-control.test.ts-51-describe('Service Control API - Production Tests', () => {
src/api/service-control.test.ts:52:  let api: any;
src/api/service-control.test.ts:53:  let app: any;
src/api/service-control.test.ts:54:  let db: any;
src/api/service-control.test.ts:55:  let sql: any;
src/api/service-control.test.ts-56-
src/api/service-control.test.ts-57-  beforeAll(async () => {
src/api/service-control.test.ts-58-    // Initialize database and API
--
src/api/service-control.test.ts-318-        AND service_name IN ('story_response', 'comment_response', 'dm_processing')
src/api/service-control.test.ts-319-      `;
src/api/service-control.test.ts-320-      
src/api/service-control.test.ts:321:      services.forEach((service: any) => {
src/api/service-control.test.ts-322-        expect(service.enabled).toBe(true);
src/api/service-control.test.ts-323-      });
src/api/service-control.test.ts-324-    });
--
src/api/service-control.test.ts-352-        WHERE merchant_id = ${TEST_MERCHANT_ID}::uuid
src/api/service-control.test.ts-353-      `;
src/api/service-control.test.ts-354-      
src/api/service-control.test.ts:355:      services.forEach((service: any) => {
src/api/service-control.test.ts-356-        expect(service.enabled).toBe(false);
src/api/service-control.test.ts-357-      });
src/api/service-control.test.ts-358-    });
--
src/api/service-control.test.ts-374-      const healthData = data.data.services;
src/api/service-control.test.ts-375-      expect(healthData.length).toBeGreaterThan(0);
src/api/service-control.test.ts-376-      
src/api/service-control.test.ts:377:      const instagramHealth = healthData.find((h: any) => h.service === 'انستغرام');
src/api/service-control.test.ts-378-      expect(instagramHealth).toBeDefined();
src/api/service-control.test.ts-379-      expect(instagramHealth.status).toMatch(/healthy|degraded|disabled|error/);
src/api/service-control.test.ts-380-    });
--
src/db/index.ts-100-    log.debug('Transaction committed');
src/db/index.ts-101-    
src/db/index.ts-102-    return result;
src/db/index.ts:103:  } catch (error: any) {
src/db/index.ts-104-    await client.query('ROLLBACK');
src/db/index.ts-105-    log.error('Transaction rolled back due to error:', error);
src/db/index.ts-106-    throw error;
--
src/db/index.ts-130-/**
src/db/index.ts-131- * Health check for database connectivity
src/db/index.ts-132- */
src/db/index.ts:133:export async function checkDatabaseHealth(): Promise<{ healthy: boolean; details: any }> {
src/db/index.ts-134-  try {
src/db/index.ts-135-    const currentPool = getPool();
src/db/index.ts-136-    const client = await currentPool.connect();
--
src/db/index.ts-150-    } finally {
src/db/index.ts-151-      client.release();
src/db/index.ts-152-    }
src/db/index.ts:153:  } catch (error: any) {
src/db/index.ts-154-    log.error('Database health check failed:', error);
src/db/index.ts-155-    return {
src/db/index.ts-156-      healthy: false,
--
src/db/index.ts-170-    try {
src/db/index.ts-171-      await pool.end();
src/db/index.ts-172-      log.info('Database pool closed successfully');
src/db/index.ts:173:    } catch (error: any) {
src/db/index.ts-174-      log.error('Error closing database pool:', error);
src/db/index.ts-175-    } finally {
src/db/index.ts-176-      pool = null;
--
src/db/index.ts-184-export async function query<T = any>(
src/db/index.ts-185-  poolOrClient: Pool | PoolClient,
src/db/index.ts-186-  text: string,
src/db/index.ts:187:  params?: any[]
src/db/index.ts-188-): Promise<T[]> {
src/db/index.ts-189-  const startTime = Date.now();
src/db/index.ts-190-  
--
src/db/index.ts-219-        client.release();
src/db/index.ts-220-      }
src/db/index.ts-221-    }
src/db/index.ts:222:  } catch (error: any) {
src/db/index.ts-223-    const duration = Date.now() - startTime;
src/db/index.ts-224-    log.error('Query failed', {
src/db/index.ts-225-      duration,
--
src/utils/timer-manager.ts-39-  patched = true;
src/utils/timer-manager.ts-40-
src/utils/timer-manager.ts-41-  global.setTimeout = (
src/utils/timer-manager.ts:42:    (handler: (...a: any[]) => void, timeout?: number, ...args: any[]) => {
src/utils/timer-manager.ts-43-      const timer = originalSetTimeout(handler, timeout, ...args);
src/utils/timer-manager.ts-44-      timerManager.register(timer);
src/utils/timer-manager.ts-45-      timer.unref?.();
--
src/utils/timer-manager.ts-48-  ) as typeof setTimeout;
src/utils/timer-manager.ts-49-
src/utils/timer-manager.ts-50-  global.setInterval = (
src/utils/timer-manager.ts:51:    (handler: (...a: any[]) => void, timeout?: number, ...args: any[]) => {
src/utils/timer-manager.ts-52-      const timer = originalSetInterval(handler, timeout, ...args);
src/utils/timer-manager.ts-53-      timerManager.register(timer);
src/utils/timer-manager.ts-54-      timer.unref?.();
--
src/api/utility-messages.ts-312-    try {
src/api/utility-messages.ts-313-      const { merchantId } = c.req.valid('param');
src/api/utility-messages.ts-314-      const db = getDatabase();
src/api/utility-messages.ts:315:      const sql = db.getSQL() as any;
src/api/utility-messages.ts-316-
src/api/utility-messages.ts-317-      try {
src/api/utility-messages.ts-318-        const [counts] = await sql<{
--
src/repos/template.repo.ts-148-  const { type, approved, limit = 50, offset = 0 } = options;
src/repos/template.repo.ts-149-  
src/repos/template.repo.ts-150-  let whereConditions = ['merchant_id = $1::uuid'];
src/repos/template.repo.ts:151:  let params: any[] = [merchantId];
src/repos/template.repo.ts-152-  let paramIndex = 2;
src/repos/template.repo.ts-153-  
src/repos/template.repo.ts-154-  if (type) {
--
src/repos/template.repo.ts-212-  }
src/repos/template.repo.ts-213-): Promise<Template | null> {
src/repos/template.repo.ts-214-  const updateFields: string[] = [];
src/repos/template.repo.ts:215:  const params: any[] = [];
src/repos/template.repo.ts-216-  let paramIndex = 1;
src/repos/template.repo.ts-217-
src/repos/template.repo.ts-218-  if (updates.name !== undefined) {
--
src/database/seed.ts-67-  private async seedMerchants(): Promise<string[]> {
src/database/seed.ts-68-    console.log('👥 Seeding merchants...');
src/database/seed.ts-69-    
src/database/seed.ts:70:    const sql = this.db.getSQL() as any;
src/database/seed.ts-71-    
src/database/seed.ts-72-    const merchantsData = [
src/database/seed.ts-73-      {
--
src/database/seed.ts-118-        instagram_user_id, email, subscription_status, 
src/database/seed.ts-119-        subscription_tier, subscription_expires_at
src/database/seed.ts-120-      ) 
src/database/seed.ts:121:      VALUES ${merchantsData.map((m: any) => [
src/database/seed.ts-122-        m.business_name, m.business_category, m.business_address,
src/database/seed.ts-123-        m.whatsapp_number, m.whatsapp_number_id, m.instagram_username,
src/database/seed.ts-124-        m.instagram_user_id, m.email, m.subscription_status,
--
src/database/seed.ts-128-    `;
src/database/seed.ts-129-
src/database/seed.ts-130-    console.log(`✅ Created ${merchants.length} merchants`);
src/database/seed.ts:131:    return merchants.map((m: any) => m.id);
src/database/seed.ts-132-  }
src/database/seed.ts-133-
src/database/seed.ts-134-  /**
--
src/database/seed.ts-137-  private async seedProducts(merchantIds: string[]): Promise<void> {
src/database/seed.ts-138-    console.log('📱 Seeding products...');
src/database/seed.ts-139-    
src/database/seed.ts:140:    const sql = this.db.getSQL() as any;
src/database/seed.ts-141-    
src/database/seed.ts-142-    // Products for Ahmed's Mobile Shop
src/database/seed.ts-143-    const ahmedProducts = [
--
src/database/seed.ts-303-        attributes, variants, images, tags, is_featured, is_on_sale, sale_price_usd
src/database/seed.ts-304-      )
src/database/seed.ts-305-      VALUES ${allProducts.map(p => [
src/database/seed.ts:306:        p.merchant_id, p.sku, p.name_ar, (p as any).name_en ?? null, p.description_ar, p.category,
src/database/seed.ts-307-        p.price_usd, p.cost_usd ?? null, p.stock_quantity, p.min_stock_alert,
src/database/seed.ts:308:        p.attributes ?? '{}', (p as any).variants ?? '[]', (p as any).images ?? '[]', 
src/database/seed.ts:309:        (p as any).tags ?? [], (p as any).is_featured ?? false, (p as any).is_on_sale ?? false, (p as any).sale_price_usd ?? null
src/database/seed.ts-310-      ])}
src/database/seed.ts-311-    `;
src/database/seed.ts-312-
--
src/database/seed.ts-319-  private async seedConversations(merchantIds: string[]): Promise<string[]> {
src/database/seed.ts-320-    console.log('💬 Seeding conversations...');
src/database/seed.ts-321-    
src/database/seed.ts:322:    const sql = this.db.getSQL() as any;
src/database/seed.ts-323-    
src/database/seed.ts-324-    const conversationsData = [
src/database/seed.ts-325-      {
--
src/database/seed.ts-404-    `;
src/database/seed.ts-405-
src/database/seed.ts-406-    console.log(`✅ Created ${conversations.length} conversations`);
src/database/seed.ts:407:    return conversations.map((c: any) => c.id);
src/database/seed.ts-408-  }
src/database/seed.ts-409-
src/database/seed.ts-410-  /**
--
src/database/seed.ts-413-  private async seedOrders(merchantIds: string[], conversationIds: string[]): Promise<void> {
src/database/seed.ts-414-    console.log('📦 Seeding orders...');
src/database/seed.ts-415-    
src/database/seed.ts:416:    const sql = this.db.getSQL() as any;
src/database/seed.ts-417-    
src/database/seed.ts-418-    const ordersData = [
src/database/seed.ts-419-      {
--
src/database/seed.ts-521-  private async seedMessageLogs(conversationIds: string[]): Promise<void> {
src/database/seed.ts-522-    console.log('📨 Seeding message logs...');
src/database/seed.ts-523-    
src/database/seed.ts:524:    const sql = this.db.getSQL() as any;
src/database/seed.ts-525-    
src/database/seed.ts-526-    // Sample messages for conversations
src/database/seed.ts-527-    const messagesData = [
--
src/database/seed.ts-580-        conversation_id, direction, platform, content, ai_processed,
src/database/seed.ts-581-        ai_response_time_ms, delivery_status, created_at
src/database/seed.ts-582-      )
src/database/seed.ts:583:      VALUES ${messagesData.map((m: any) => [
src/database/seed.ts-584-        m.conversation_id, m.direction, m.platform, m.content, m.ai_processed,
src/database/seed.ts-585-        m.ai_response_time_ms || null, m.delivery_status || 'DELIVERED', m.created_at
src/database/seed.ts-586-      ])}
--
src/api/instagram-auth.ts-253-      error: errorMessage,
src/api/instagram-auth.ts-254-      details: err.message,
src/api/instagram-auth.ts-255-      timestamp: new Date().toISOString()
src/api/instagram-auth.ts:256:    }, statusCode as any);
src/api/instagram-auth.ts-257-  }
src/api/instagram-auth.ts-258-});
src/api/instagram-auth.ts-259-
--
src/api/instagram-auth.ts-309-      });
src/api/instagram-auth.ts-310-    }
src/api/instagram-auth.ts-311-    
src/api/instagram-auth.ts:312:    const account = integration[0] as any;
src/api/instagram-auth.ts-313-    const isExpired = account.token_expires_at && 
src/api/instagram-auth.ts-314-      new Date() >= new Date(account.token_expires_at);
src/api/instagram-auth.ts-315-    
--
src/api/instagram-auth.ts-415-      return c.json({ error: 'No token found for merchant' }, 404);
src/api/instagram-auth.ts-416-    }
src/api/instagram-auth.ts-417-
src/api/instagram-auth.ts:418:    const currentToken = (result[0] as any).instagram_access_token;
src/api/instagram-auth.ts-419-    const refreshedToken = await oauthService.refreshLongLivedToken(currentToken, merchantId);
src/api/instagram-auth.ts-420-
src/api/instagram-auth.ts-421-    const newExpiresAt = new Date(Date.now() + (refreshedToken.expires_in * 1000));
--
src/api/instagram-auth.ts-481-
src/api/instagram-auth.ts-482-    const record = result[0];
src/api/instagram-auth.ts-483-    const now = new Date();
src/api/instagram-auth.ts:484:    const expiresAt = new Date((record as any).token_expires_at);
src/api/instagram-auth.ts-485-
src/api/instagram-auth.ts-486-    if (expiresAt <= now) {
src/api/instagram-auth.ts-487-      return c.json({
--
src/api/instagram-auth.ts-493-    }
src/api/instagram-auth.ts-494-
src/api/instagram-auth.ts-495-    const oauthService = getInstagramOAuthService();
src/api/instagram-auth.ts:496:    const isValid = await oauthService.validateToken((record as any).instagram_access_token);
src/api/instagram-auth.ts-497-
src/api/instagram-auth.ts-498-    return c.json({
src/api/instagram-auth.ts-499-      success: true,
--
src/api/service-controller.ts-80-  /**
src/api/service-controller.ts-81-   * Toggle service on/off
src/api/service-controller.ts-82-   */
src/api/service-controller.ts:83:  private async toggleService(c: any) {
src/api/service-controller.ts-84-    try {
src/api/service-controller.ts-85-      const data = c.req.valid('json');
src/api/service-controller.ts-86-      
--
src/repos/message.repo.ts-85-    templateId: row.template_id,
src/repos/message.repo.ts-86-    messageId: row.message_id,
src/repos/message.repo.ts-87-    messageType: row.message_type as UtilityMessageType,
src/repos/message.repo.ts:88:    status: row.status as any,
src/repos/message.repo.ts-89-    sentAt: row.sent_at,
src/repos/message.repo.ts-90-    deliveredAt: row.delivered_at,
src/repos/message.repo.ts-91-    readAt: row.read_at,
--
src/repos/message.repo.ts-104-  errorMessage?: string
src/repos/message.repo.ts-105-): Promise<boolean> {
src/repos/message.repo.ts-106-  const updates: string[] = ['status = $2'];
src/repos/message.repo.ts:107:  const params: any[] = [messageId, status];
src/repos/message.repo.ts-108-  let paramIndex = 3;
src/repos/message.repo.ts-109-
src/repos/message.repo.ts-110-  if (status === 'delivered') {
--
src/repos/message.repo.ts-151-  const { recipientId, templateId, messageType, status, startDate, endDate, limit = 50, offset = 0 } = options;
src/repos/message.repo.ts-152-  
src/repos/message.repo.ts-153-  let whereConditions = ['l.merchant_id = $1::uuid'];
src/repos/message.repo.ts:154:  let params: any[] = [merchantId];
src/repos/message.repo.ts-155-  let paramIndex = 2;
src/repos/message.repo.ts-156-  
src/repos/message.repo.ts-157-  if (recipientId) {
--
src/repos/message.repo.ts-226-    templateId: row.template_id,
src/repos/message.repo.ts-227-    messageId: row.message_id,
src/repos/message.repo.ts-228-    messageType: row.message_type as UtilityMessageType,
src/repos/message.repo.ts:229:    status: row.status as any,
src/repos/message.repo.ts-230-    sentAt: row.sent_at,
src/repos/message.repo.ts-231-    deliveredAt: row.delivered_at,
src/repos/message.repo.ts-232-    readAt: row.read_at,
--
src/repos/message.repo.ts-271-  }
src/repos/message.repo.ts-272-  
src/repos/message.repo.ts-273-  let whereConditions = ['merchant_id = $1::uuid'];
src/repos/message.repo.ts:274:  let params: any[] = [merchantId];
src/repos/message.repo.ts-275-  let paramIndex = 2;
src/repos/message.repo.ts-276-  
src/repos/message.repo.ts-277-  if (startDate) {
--
src/errors/RedisErrors.ts-133-
src/errors/RedisErrors.ts-134-// Error Factory لإنشاء الأخطاء بناءً على نوع المشكلة
src/errors/RedisErrors.ts-135-export class RedisErrorFactory {
src/errors/RedisErrors.ts:136:  static createFromIORedisError(error: any, context?: Record<string, any>): RedisBaseError {
src/errors/RedisErrors.ts-137-    const message = error.message || 'Unknown Redis error';
src/errors/RedisErrors.ts-138-    
src/errors/RedisErrors.ts-139-    if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
--
src/errors/RedisErrors.ts-194-
src/errors/RedisErrors.ts-195-  static createValidationError(
src/errors/RedisErrors.ts-196-    field: string, 
src/errors/RedisErrors.ts:197:    value: any, 
src/errors/RedisErrors.ts-198-    expectedType?: string
src/errors/RedisErrors.ts-199-  ): RedisValidationError {
src/errors/RedisErrors.ts-200-    const message = expectedType 
--
src/errors/RedisErrors.ts-251-
src/errors/RedisErrors.ts-252-// Error Handler Utility
src/errors/RedisErrors.ts-253-export class RedisErrorHandler {
src/errors/RedisErrors.ts:254:  constructor(private logger?: any) {}
src/errors/RedisErrors.ts-255-
src/errors/RedisErrors.ts-256-  handleError(error: unknown, context?: Record<string, any>): RedisBaseError {
src/errors/RedisErrors.ts-257-    let redisError: RedisBaseError;
--
src/infrastructure/db/sql-tag.ts-1-// src/infrastructure/db/sql-tag.ts
src/infrastructure/db/sql-tag.ts-2-import type { Pool } from 'pg';
src/infrastructure/db/sql-tag.ts-3-
src/infrastructure/db/sql-tag.ts:4:export type SQLTag = (strings: TemplateStringsArray, ...values: any[]) => Promise<any[]>;
src/infrastructure/db/sql-tag.ts-5-
src/infrastructure/db/sql-tag.ts:6:function compileTemplate(strings: TemplateStringsArray, values: any[]) {
src/infrastructure/db/sql-tag.ts-7-  // يبني نص استعلام بـ $1, $2 ... ويجمع values بالترتيب
src/infrastructure/db/sql-tag.ts-8-  const text = strings.reduce((acc, s, i) => acc + s + (i < values.length ? `$${i + 1}` : ''), '');
src/infrastructure/db/sql-tag.ts-9-  return { text, values };
--
src/infrastructure/db/sql-tag.ts-15- * يرجّع rows مباشرةً (array)
src/infrastructure/db/sql-tag.ts-16- */
src/infrastructure/db/sql-tag.ts-17-export function buildSQLTag(pool: Pool): SQLTag {
src/infrastructure/db/sql-tag.ts:18:  return async (strings: TemplateStringsArray, ...values: any[]) => {
src/infrastructure/db/sql-tag.ts-19-    const { text, values: params } = compileTemplate(strings, values);
src/infrastructure/db/sql-tag.ts-20-    const { rows } = await pool.query(text, params);
src/infrastructure/db/sql-tag.ts-21-    return rows;
--
src/database/rls-wrapper.ts-28-      throw new Error('merchantId is required for RLS context');
src/database/rls-wrapper.ts-29-    }
src/database/rls-wrapper.ts-30-
src/database/rls-wrapper.ts:31:    const sql = this.db.getSQL() as any;
src/database/rls-wrapper.ts-32-    try {
src/database/rls-wrapper.ts-33-      // سياق محلي داخل التراكنشن
src/database/rls-wrapper.ts-34-      await sql`SET LOCAL app.tenant_id = ${merchantId}`;
--
src/database/rls-wrapper.ts-57-      throw new Error('setAdminContext is restricted in production');
src/database/rls-wrapper.ts-58-    }
src/database/rls-wrapper.ts-59-
src/database/rls-wrapper.ts:60:    const sql = this.db.getSQL() as any;
src/database/rls-wrapper.ts-61-    try {
src/database/rls-wrapper.ts-62-      await sql`SET LOCAL app.is_admin = ${isAdmin ? 'true' : 'false'}`;
src/database/rls-wrapper.ts-63-
--
src/database/rls-wrapper.ts-77-   * Clear all RLS context
src/database/rls-wrapper.ts-78-   */
src/database/rls-wrapper.ts-79-  async clearContext(): Promise<void> {
src/database/rls-wrapper.ts:80:    const sql = this.db.getSQL() as any;
src/database/rls-wrapper.ts-81-    
src/database/rls-wrapper.ts-82-    try {
src/database/rls-wrapper.ts-83-      // Clear all LOCAL settings (automatic at transaction end for pooled connections)
--
src/database/rls-wrapper.ts-100-    contextAgeSeconds: number;
src/database/rls-wrapper.ts-101-    isValid: boolean;
src/database/rls-wrapper.ts-102-  }> {
src/database/rls-wrapper.ts:103:    const sql = this.db.getSQL() as any;
src/database/rls-wrapper.ts-104-    
src/database/rls-wrapper.ts-105-    try {
src/database/rls-wrapper.ts-106-      const [result] = await sql`SELECT * FROM validate_rls_context()`;
--
src/database/rls-wrapper.ts-126-  /**
src/database/rls-wrapper.ts-127-   * Execute query with automatic context validation
src/database/rls-wrapper.ts-128-   */
src/database/rls-wrapper.ts:129:  async query<T>(strings: TemplateStringsArray, ...params: any[]): Promise<T[]> {
src/database/rls-wrapper.ts-130-    // التحقق من السياق قبل التنفيذ
src/database/rls-wrapper.ts-131-    const contextValidation = await this.validateContext();
src/database/rls-wrapper.ts-132-
--
src/database/rls-wrapper.ts-138-    }
src/database/rls-wrapper.ts-139-
src/database/rls-wrapper.ts-140-    const sql = this.db.getSQL();
src/database/rls-wrapper.ts:141:    return await (sql as any)(strings, ...params);
src/database/rls-wrapper.ts-142-  }
src/database/rls-wrapper.ts-143-
src/database/rls-wrapper.ts-144-  /**
--
src/database/rls-wrapper.ts-148-    callback: (sql: Sql) => Promise<T>,
src/database/rls-wrapper.ts-149-    merchantId?: string
src/database/rls-wrapper.ts-150-  ): Promise<T> {
src/database/rls-wrapper.ts:151:    const sql = this.db.getSQL() as any;
src/database/rls-wrapper.ts:152:    return await sql.transaction(async (trx: any) => {
src/database/rls-wrapper.ts-153-      // إعداد السياق داخل التراكنشن
src/database/rls-wrapper.ts-154-      if (merchantId) {
src/database/rls-wrapper.ts-155-        await trx`SELECT set_merchant_context(${merchantId}::uuid)`;
--
src/database/rls-wrapper.ts-222-  /**
src/database/rls-wrapper.ts-223-   * Internal helper to log security-related actions
src/database/rls-wrapper.ts-224-   */
src/database/rls-wrapper.ts:225:  private async logAudit(action: string, userId?: string, details?: any): Promise<void> {
src/database/rls-wrapper.ts-226-    try {
src/database/rls-wrapper.ts:227:      const sql = this.db.getSQL() as any;
src/database/rls-wrapper.ts-228-      await sql`
src/database/rls-wrapper.ts-229-        INSERT INTO audit_logs (
src/database/rls-wrapper.ts-230-          action,
--
src/database/rls-wrapper.ts-258-export class RLSContextError extends Error {
src/database/rls-wrapper.ts-259-  constructor(
src/database/rls-wrapper.ts-260-    message: string,
src/database/rls-wrapper.ts:261:    public readonly contextInfo: any
src/database/rls-wrapper.ts-262-  ) {
src/database/rls-wrapper.ts-263-    super(message);
src/database/rls-wrapper.ts-264-    this.name = 'RLSContextError';
--
src/errors/RedisErrors.test.ts-30-} from './RedisErrors.js';
src/errors/RedisErrors.test.ts-31-
src/errors/RedisErrors.test.ts-32-describe('Redis Errors - أخطاء Redis', () => {
src/errors/RedisErrors.test.ts:33:  let mockLogger: any;
src/errors/RedisErrors.test.ts-34-
src/errors/RedisErrors.test.ts-35-  beforeEach(() => {
src/errors/RedisErrors.test.ts-36-    mockLogger = {
--
src/queue/db-spool.ts-13-  id: string;
src/queue/db-spool.ts-14-  jobId: string;
src/queue/db-spool.ts-15-  jobType: string;
src/queue/db-spool.ts:16:  jobData: any;
src/queue/db-spool.ts-17-  priority: 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';
src/queue/db-spool.ts-18-  merchantId: string;
src/queue/db-spool.ts-19-  scheduledAt: Date;
--
src/queue/db-spool.ts-24-export interface SpoolJobRequest {
src/queue/db-spool.ts-25-  jobId: string;
src/queue/db-spool.ts-26-  jobType: string;
src/queue/db-spool.ts:27:  jobData: any;
src/queue/db-spool.ts-28-  priority?: 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';
src/queue/db-spool.ts-29-  merchantId: string;
src/queue/db-spool.ts-30-  scheduledAt?: Date;
--
src/queue/db-spool.ts-172-        byType: {} as Record<string, number>
src/queue/db-spool.ts-173-      };
src/queue/db-spool.ts-174-
src/queue/db-spool.ts:175:      priorityResult.forEach((row: any) => {
src/queue/db-spool.ts-176-        stats.byPriority[row.priority] = parseInt(row.count);
src/queue/db-spool.ts-177-      });
src/queue/db-spool.ts-178-
src/queue/db-spool.ts:179:      typeResult.forEach((row: any) => {
src/queue/db-spool.ts-180-        stats.byType[row.job_type] = parseInt(row.count);
src/queue/db-spool.ts-181-      });
src/queue/db-spool.ts-182-
--
src/queue/db-spool.ts-203-        AND processed_at < ${cutoffTime}
src/queue/db-spool.ts-204-      `;
src/queue/db-spool.ts-205-
src/queue/db-spool.ts:206:      const deletedCount = (result as any).count || 0;
src/queue/db-spool.ts-207-      
src/queue/db-spool.ts-208-      if (deletedCount > 0) {
src/queue/db-spool.ts-209-        this.logger.info('Cleaned up processed spool jobs', {
--
src/queue/db-spool.ts-229-      AND merchant_id = ${merchantId}
src/queue/db-spool.ts-230-    `;
src/queue/db-spool.ts-231-
src/queue/db-spool.ts:232:    return ((result as any).count || 0) > 0;
src/queue/db-spool.ts-233-  }
src/queue/db-spool.ts-234-
src/queue/db-spool.ts-235-  /**
--
src/queue/db-spool.ts-243-    return stats.pending > 50;
src/queue/db-spool.ts-244-  }
src/queue/db-spool.ts-245-
src/queue/db-spool.ts:246:  private mapSpooledJob(row: any): SpooledJob {
src/queue/db-spool.ts:247:    let jobData: any;
src/queue/db-spool.ts-248-    try {
src/queue/db-spool.ts-249-      jobData = typeof row.job_data === 'string' ? 
src/queue/db-spool.ts-250-        JSON.parse(row.job_data) : row.job_data;
--
src/internal/test/dev-routes.ts-15-    console.log(' RLS Context cleared');
src/internal/test/dev-routes.ts-16-  }
src/internal/test/dev-routes.ts-17-
src/internal/test/dev-routes.ts:18:  async query(sql: string, params: any[] = []): Promise<any[]> {
src/internal/test/dev-routes.ts-19-    console.log(` Mock DB Query: ${sql}`, { params, context: this.currentMerchantId });
src/internal/test/dev-routes.ts-20-
src/internal/test/dev-routes.ts-21-    // Simulate RLS behavior
--
src/internal/test/dev-routes.ts-27-    return [{ id: 1, merchant_id: this.currentMerchantId, test: 'data' }];
src/internal/test/dev-routes.ts-28-  }
src/internal/test/dev-routes.ts-29-
src/internal/test/dev-routes.ts:30:  async testRLS(): Promise<{ withoutContext: any[]; withContext: any[] }> {
src/internal/test/dev-routes.ts-31-    // Test without context
src/internal/test/dev-routes.ts-32-    this.clearMerchantContext();
src/internal/test/dev-routes.ts-33-    const withoutContext = await this.query('SELECT * FROM merchants');
--
src/internal/test/dev-routes.ts-42-
src/internal/test/dev-routes.ts-43-class MockQueueService {
src/internal/test/dev-routes.ts-44-  private jobs: Map<string, any> = new Map();
src/internal/test/dev-routes.ts:45:  private dlq: any[] = [];
src/internal/test/dev-routes.ts-46-  private processedEvents: Set<string> = new Set();
src/internal/test/dev-routes.ts-47-
src/internal/test/dev-routes.ts:48:  async addJob(eventId: string, data: any): Promise<{ duplicate: boolean; jobId?: string }> {
src/internal/test/dev-routes.ts-49-    // Idempotency check
src/internal/test/dev-routes.ts-50-    if (this.processedEvents.has(eventId)) {
src/internal/test/dev-routes.ts-51-      console.log(` Idempotency collision detected: ${eventId}`);
--
src/internal/test/dev-routes.ts-86-    }
src/internal/test/dev-routes.ts-87-  }
src/internal/test/dev-routes.ts-88-
src/internal/test/dev-routes.ts:89:  getDLQStats(): { jobs: number; entries: any[] } {
src/internal/test/dev-routes.ts-90-    return { jobs: this.dlq.length, entries: this.dlq };
src/internal/test/dev-routes.ts-91-  }
src/internal/test/dev-routes.ts-92-}
--
src/production-index.ts-89-      const contentType = c.req.header('content-type');
src/production-index.ts-90-      if (contentType?.includes('application/json')) {
src/production-index.ts-91-        const body = await c.req.arrayBuffer();
src/production-index.ts:92:        (c as any).rawBody = Buffer.from(body);
src/production-index.ts-93-      }
src/production-index.ts-94-      await next();
src/production-index.ts-95-    });
--
src/production-index.ts-171-    });
src/production-index.ts-172-
src/production-index.ts-173-    return app;
src/production-index.ts:174:  } catch (error: any) {
src/production-index.ts-175-    log.error('❌ Bootstrap failed:', error);
src/production-index.ts-176-    process.exit(1);
src/production-index.ts-177-  }
--
src/production-index.ts-196-    
src/production-index.ts-197-    log.info('✅ Graceful shutdown completed');
src/production-index.ts-198-    process.exit(0);
src/production-index.ts:199:  } catch (error: any) {
src/production-index.ts-200-    log.error('❌ Error during shutdown:', error);
src/production-index.ts-201-    process.exit(1);
src/production-index.ts-202-  }
--
src/startup/maintenance.ts-30-    }
src/startup/maintenance.ts-31-
src/startup/maintenance.ts-32-    log.info('✅ Maintenance tasks scheduled successfully');
src/startup/maintenance.ts:33:  } catch (error: any) {
src/startup/maintenance.ts-34-    log.error('❌ Failed to schedule maintenance tasks:', error);
src/startup/maintenance.ts-35-  }
src/startup/maintenance.ts-36-}
--
src/startup/maintenance.ts-38-/**
src/startup/maintenance.ts-39- * Schedule maintenance tasks using the queue manager
src/startup/maintenance.ts-40- */
src/startup/maintenance.ts:41:function scheduleQueueMaintenanceTasks(queueManager: any): void {
src/startup/maintenance.ts-42-  const now = new Date();
src/startup/maintenance.ts-43-  
src/startup/maintenance.ts-44-  // Schedule daily cleanup at 2 AM
--
src/startup/maintenance.ts-56-    payload: { type: 'end_inactive_conversations', inactiveDays: 30 },
src/startup/maintenance.ts-57-    priority: 'LOW',
src/startup/maintenance.ts-58-    scheduledAt: cleanupTime
src/startup/maintenance.ts:59:  }).catch((error: any) => {
src/startup/maintenance.ts-60-    log.error('Failed to schedule conversation cleanup:', error);
src/startup/maintenance.ts-61-  });
src/startup/maintenance.ts-62-
--
src/startup/maintenance.ts-66-    payload: { type: 'delete_old_messages', days: 90 },
src/startup/maintenance.ts-67-    priority: 'LOW',
src/startup/maintenance.ts-68-    scheduledAt: new Date(cleanupTime.getTime() + 30 * 60 * 1000)
src/startup/maintenance.ts:69:  }).catch((error: any) => {
src/startup/maintenance.ts-70-    log.error('Failed to schedule message cleanup:', error);
src/startup/maintenance.ts-71-  });
src/startup/maintenance.ts-72-
--
src/startup/maintenance.ts-78-    payload: { type: 'cleanup_old_jobs', days: 7 },
src/startup/maintenance.ts-79-    priority: 'LOW',
src/startup/maintenance.ts-80-    scheduledAt: queueCleanupTime
src/startup/maintenance.ts:81:  }).catch((error: any) => {
src/startup/maintenance.ts-82-    log.error('Failed to schedule queue cleanup:', error);
src/startup/maintenance.ts-83-  });
src/startup/maintenance.ts-84-
--
src/startup/maintenance.ts-128-      }
src/startup/maintenance.ts-129-      
src/startup/maintenance.ts-130-      log.info('✅ Basic maintenance completed');
src/startup/maintenance.ts:131:    } catch (error: any) {
src/startup/maintenance.ts-132-      log.error('❌ Basic maintenance failed:', error);
src/startup/maintenance.ts-133-    }
src/startup/maintenance.ts-134-  }, cleanupInterval);
--
src/startup/maintenance.ts-177-    }
src/startup/maintenance.ts-178-    
src/startup/maintenance.ts-179-    log.info('✅ Maintenance check completed');
src/startup/maintenance.ts:180:  } catch (error: any) {
src/startup/maintenance.ts-181-    log.error('❌ Maintenance check failed:', error);
src/startup/maintenance.ts-182-  }
src/startup/maintenance.ts-183-}
--
src/startup/validation.ts-14-  service: string;
src/startup/validation.ts-15-  message: string;
src/startup/validation.ts-16-  duration: number;
src/startup/validation.ts:17:  details?: any;
src/startup/validation.ts-18-}
src/startup/validation.ts-19-
src/startup/validation.ts-20-export interface StartupValidationReport {
--
src/startup/validation.ts-591-export async function validateMerchantConfig(merchantId: string): Promise<boolean> {
src/startup/validation.ts-592-  try {
src/startup/validation.ts-593-    const db = getDatabase();
src/startup/validation.ts:594:    const sql = db.getSQL() as any;
src/startup/validation.ts-595-
src/startup/validation.ts-596-    // Check if merchant exists and is active
src/startup/validation.ts-597-    const [merchant] = await sql<{ id: string; is_active: boolean; business_name: string }>`
--
src/startup/runMigrations.ts-40-      await client.query('COMMIT');
src/startup/runMigrations.ts-41-      console.log('✅ Migration done:', f);
src/startup/runMigrations.ts-42-    }
src/startup/runMigrations.ts:43:  } catch (e: any) {
src/startup/runMigrations.ts-44-    await client.query('ROLLBACK');
src/startup/runMigrations.ts-45-    console.error('⚠️ Migration failed (non-fatal):', e.message);
src/startup/runMigrations.ts-46-  } finally {
--
src/middleware/security.ts-102-    try {
src/middleware/security.ts-103-      await limiter.consume(key);
src/middleware/security.ts-104-      await next();
src/middleware/security.ts:105:    } catch (rejRes: any) {
src/middleware/security.ts-106-      const secs = Math.round(rejRes.msBeforeNext / 1000) || 1;
src/middleware/security.ts-107-      
src/middleware/security.ts-108-      c.header('Retry-After', String(secs));
--
src/middleware/security.ts-139-    try {
src/middleware/security.ts-140-      await limiter.consume(key);
src/middleware/security.ts-141-      await next();
src/middleware/security.ts:142:    } catch (rejRes: any) {
src/middleware/security.ts-143-      const secs = Math.round(rejRes.msBeforeNext / 1000) || 1;
src/middleware/security.ts-144-      
src/middleware/security.ts-145-      return c.json({
--
src/middleware/security.ts-239-    try {
src/middleware/security.ts-240-      await limiter.consume(key);
src/middleware/security.ts-241-      await next();
src/middleware/security.ts:242:    } catch (rejRes: any) {
src/middleware/security.ts-243-      const secs = Math.round(rejRes.msBeforeNext / 1000) || 1;
src/middleware/security.ts-244-      
src/middleware/security.ts-245-      return c.json({
--
src/middleware/rls-merchant-isolation.ts-40-  // Safe header getter (يدعم كل الحالات)
src/middleware/rls-merchant-isolation.ts-41-  const getHeader = (c: Context, name: string): string | undefined => {
src/middleware/rls-merchant-isolation.ts-42-    try {
src/middleware/rls-merchant-isolation.ts:43:      const h1 = (c.req as any).header?.(name);
src/middleware/rls-merchant-isolation.ts-44-      if (h1 != null) return h1 as string;
src/middleware/rls-merchant-isolation.ts-45-      const h2 = c.req.raw?.headers?.get(name);
src/middleware/rls-merchant-isolation.ts-46-      if (h2 != null) return h2;
src/middleware/rls-merchant-isolation.ts:47:      const h3 = (c.req as any).headers?.get?.(name);
src/middleware/rls-merchant-isolation.ts-48-      return h3 ?? undefined;
src/middleware/rls-merchant-isolation.ts-49-    } catch {
src/middleware/rls-merchant-isolation.ts-50-      return undefined;
--
src/middleware/rls-merchant-isolation.ts-57-      const u = new URL(c.req.url);
src/middleware/rls-merchant-isolation.ts-58-      return u.searchParams.get(name) ?? undefined;
src/middleware/rls-merchant-isolation.ts-59-    } catch {
src/middleware/rls-merchant-isolation.ts:60:      const q = (c.req as any).query?.(name);
src/middleware/rls-merchant-isolation.ts-61-      return q ?? undefined;
src/middleware/rls-merchant-isolation.ts-62-    }
src/middleware/rls-merchant-isolation.ts-63-  };
--
src/middleware/rls-merchant-isolation.ts-219- * Create SQL template with automatic merchant isolation
src/middleware/rls-merchant-isolation.ts-220- * This ensures all queries automatically filter by current merchant
src/middleware/rls-merchant-isolation.ts-221- */
src/middleware/rls-merchant-isolation.ts:222:export function createMerchantSQL(sql: any) {
src/middleware/rls-merchant-isolation.ts-223-  return {
src/middleware/rls-merchant-isolation.ts-224-    /**
src/middleware/rls-merchant-isolation.ts-225-     * Execute query with automatic merchant verification
--
src/middleware/security.test.ts-79-
src/middleware/security.test.ts-80-describe('🔒 Security Middleware Tests', () => {
src/middleware/security.test.ts-81-  let app: Hono;
src/middleware/security.test.ts:82:  let client: any;
src/middleware/security.test.ts-83-
src/middleware/security.test.ts-84-  beforeEach(() => {
src/middleware/security.test.ts-85-    app = new Hono();
--
src/middleware/security.test.ts-112-            return undefined;
src/middleware/security.test.ts-113-          })
src/middleware/security.test.ts-114-        }
src/middleware/security.test.ts:115:      } as any as Context;
src/middleware/security.test.ts-116-
src/middleware/security.test.ts-117-      const ip = getClientIP(mockContext);
src/middleware/security.test.ts-118-      expect(ip).toBe('192.168.1.1');
--
src/middleware/security.test.ts-126-            return undefined;
src/middleware/security.test.ts-127-          })
src/middleware/security.test.ts-128-        }
src/middleware/security.test.ts:129:      } as any as Context;
src/middleware/security.test.ts-130-
src/middleware/security.test.ts-131-      const ip = getClientIP(mockContext);
src/middleware/security.test.ts-132-      expect(ip).toBe('192.168.1.1');
--
src/middleware/security.test.ts-137-        req: {
src/middleware/security.test.ts-138-          header: jest.fn(() => undefined)
src/middleware/security.test.ts-139-        }
src/middleware/security.test.ts:140:      } as any as Context;
src/middleware/security.test.ts-141-
src/middleware/security.test.ts-142-      const ip = getClientIP(mockContext);
src/middleware/security.test.ts-143-      expect(ip).toBe('unknown');
--
src/middleware/security.test.ts-151-            return undefined;
src/middleware/security.test.ts-152-          })
src/middleware/security.test.ts-153-        }
src/middleware/security.test.ts:154:      } as any as Context;
src/middleware/security.test.ts-155-
src/middleware/security.test.ts-156-      const ip = getClientIP(mockContext);
src/middleware/security.test.ts-157-      expect(ip).toBe('192.168.1.1');
--
src/startup/ensurePageMapping.ts-57-
src/startup/ensurePageMapping.ts-58-    await client.query('COMMIT');
src/startup/ensurePageMapping.ts-59-    console.log('✅ ensurePageMapping: ok for page', pageId, 'merchant', merchantId);
src/startup/ensurePageMapping.ts:60:  } catch (e: any) {
src/startup/ensurePageMapping.ts-61-    await client.query('ROLLBACK');
src/startup/ensurePageMapping.ts-62-    console.error('❌ ensurePageMapping failed:', e.message);
src/startup/ensurePageMapping.ts-63-  } finally {
--
src/middleware/auto-tenant-context.ts-124-        issuer: config.jwtIssuer,
src/middleware/auto-tenant-context.ts-125-        audience: config.jwtAudience,
src/middleware/auto-tenant-context.ts-126-        clockTolerance: 30, // seconds
src/middleware/auto-tenant-context.ts:127:      }) as any;
src/middleware/auto-tenant-context.ts-128-
src/middleware/auto-tenant-context.ts-129-      const isAdmin = !!payload?.roles?.some((r: string) => config.adminRoles?.includes(r));
src/middleware/auto-tenant-context.ts-130-      const merchantId = payload.merchantId || payload.merchant_id;
--
src/startup/redis.ts-80-    }
src/startup/redis.ts-81-
src/startup/redis.ts-82-    return initializationResult;
src/startup/redis.ts:83:  } catch (error: any) {
src/startup/redis.ts-84-    log.error('❌ Redis integration initialization failed', error);
src/startup/redis.ts-85-    
src/startup/redis.ts-86-    initializationResult = {
--
src/startup/redis.ts-135-    await connectionManager.closeAllConnections();
src/startup/redis.ts-136-    
src/startup/redis.ts-137-    log.info('Redis connections closed');
src/startup/redis.ts:138:  } catch (error: any) {
src/startup/redis.ts-139-    log.error('Error closing Redis connections:', error);
src/startup/redis.ts-140-  }
src/startup/redis.ts-141-}
--
src/startup/validation.test.ts-50-  getSQL: mock(() => mockSQL)
src/startup/validation.test.ts-51-};
src/startup/validation.test.ts-52-
src/startup/validation.test.ts:53:const mockSQL = mock((strings: TemplateStringsArray, ...values: any[]) => {
src/startup/validation.test.ts-54-  const query = strings.join('?');
src/startup/validation.test.ts-55-  
src/startup/validation.test.ts-56-  // Mock table existence check
--
src/startup/validation.test.ts-108-  json: () => Promise.resolve({ data: [] })
src/startup/validation.test.ts-109-}));
src/startup/validation.test.ts-110-
src/startup/validation.test.ts:111:global.fetch = mockFetch as any;
src/startup/validation.test.ts-112-
src/startup/validation.test.ts-113-describe('Startup Validation - التحقق من صحة البدء', () => {
src/startup/validation.test.ts-114-  let originalEnv: NodeJS.ProcessEnv;
src/startup/validation.test.ts:115:  let consoleSpy: any;
src/startup/validation.test.ts-116-
src/startup/validation.test.ts-117-  beforeEach(() => {
src/startup/validation.test.ts-118-    // Save original environment
--
src/middleware/idempotency.ts-184-/**
src/middleware/idempotency.ts-185- * Hash merchant and body pattern for audit compliance
src/middleware/idempotency.ts-186- */
src/middleware/idempotency.ts:187:export function hashMerchantAndBody(merchantId: string, body: any): string {
src/middleware/idempotency.ts-188-  const content = `${merchantId}:${JSON.stringify(body)}`;
src/middleware/idempotency.ts-189-  return crypto.createHash('sha256').update(content).digest('hex');
src/middleware/idempotency.ts-190-}
--
src/types/shims.d.ts-16-interface InstagramAPIResponse { 
src/types/shims.d.ts-17-  messageId?: string; 
src/types/shims.d.ts-18-  message_id?: string;
src/types/shims.d.ts:19:  [k: string]: any; 
src/types/shims.d.ts-20-}
src/types/shims.d.ts-21-
src/types/shims.d.ts-22-
--
src/services/instagram-oauth.ts-21-export type { InstagramOAuthCredentials } from '../types/instagram.js';
src/services/instagram-oauth.ts-22-
src/services/instagram-oauth.ts-23-// safe JSON helper for non-typed responses
src/services/instagram-oauth.ts:24:const jsonAny = async (r: any): Promise<any> => {
src/services/instagram-oauth.ts-25-  try { return await r.json(); } catch { return {}; }
src/services/instagram-oauth.ts-26-};
src/services/instagram-oauth.ts-27-
--
src/services/instagram-oauth.ts-135-      if (!res.ok) {
src/services/instagram-oauth.ts-136-        const errBody = await res.text().catch(() => '');
src/services/instagram-oauth.ts-137-        const e = new Error(`Instagram OAuth Graph error ${res.status}: ${errBody}`);
src/services/instagram-oauth.ts:138:        (e as any).status = res.status;
src/services/instagram-oauth.ts-139-        throw e;
src/services/instagram-oauth.ts-140-      }
src/services/instagram-oauth.ts-141-
src/services/instagram-oauth.ts-142-      return res.json() as Promise<T>;
src/services/instagram-oauth.ts:143:    } catch (err: any) {
src/services/instagram-oauth.ts-144-      clearTimeout(timeout);
src/services/instagram-oauth.ts-145-      if (err?.name === 'AbortError') {
src/services/instagram-oauth.ts-146-        throw new Error('Instagram OAuth Graph request timed out');
--
src/services/instagram-oauth.ts-287-      }
src/services/instagram-oauth.ts-288-
src/services/instagram-oauth.ts-289-      const jsonAny = async (r: Response): Promise<any> => { try { return await r.json(); } catch { return {}; } };
src/services/instagram-oauth.ts:290:      const data: any = await jsonAny(response);
src/services/instagram-oauth.ts-291-      
src/services/instagram-oauth.ts-292-      if (!data.access_token || !data.user_id) {
src/services/instagram-oauth.ts-293-        this.logger.error('❌ Invalid token response:', data);
--
src/services/instagram-oauth.ts-336-        access_token: shortLivedToken
src/services/instagram-oauth.ts-337-      };
src/services/instagram-oauth.ts-338-
src/services/instagram-oauth.ts:339:      const data: any = await this.graphRequest<any>(
src/services/instagram-oauth.ts-340-        'GET',
src/services/instagram-oauth.ts-341-        'https://graph.instagram.com/access_token',
src/services/instagram-oauth.ts-342-        params
--
src/services/instagram-oauth.ts-368-        access_token: currentToken
src/services/instagram-oauth.ts-369-      };
src/services/instagram-oauth.ts-370-
src/services/instagram-oauth.ts:371:      const data: any = await this.graphRequest<any>(
src/services/instagram-oauth.ts-372-        'GET',
src/services/instagram-oauth.ts-373-        'https://graph.instagram.com/refresh_access_token',
src/services/instagram-oauth.ts-374-        params,
--
src/services/instagram-oauth.ts-397-        access_token: accessToken
src/services/instagram-oauth.ts-398-      };
src/services/instagram-oauth.ts-399-
src/services/instagram-oauth.ts:400:      const data: any = await this.graphRequest<any>(
src/services/instagram-oauth.ts-401-        'GET',
src/services/instagram-oauth.ts-402-        'https://graph.instagram.com/me',
src/services/instagram-oauth.ts-403-        params
--
src/services/instagram-oauth.ts-437-        throw new Error('Failed to fetch permissions');
src/services/instagram-oauth.ts-438-      }
src/services/instagram-oauth.ts-439-
src/services/instagram-oauth.ts:440:      const data: any = await jsonAny(response);
src/services/instagram-oauth.ts:441:      const grantedPerms = (data.data ?? []).map((p: any) => p.permission);
src/services/instagram-oauth.ts-442-      const grantedPermissions = grantedPerms;
src/services/instagram-oauth.ts-443-
src/services/instagram-oauth.ts-444-      // Updated required scopes for 2025 Instagram Business Login
--
src/services/instagram-oauth.ts-502-        throw new Error('Failed to fetch Facebook pages');
src/services/instagram-oauth.ts-503-      }
src/services/instagram-oauth.ts-504-
src/services/instagram-oauth.ts:505:      const pagesData: any = await jsonAny(pagesResponse);
src/services/instagram-oauth.ts-506-      const pages = pagesData.data || [];
src/services/instagram-oauth.ts-507-
src/services/instagram-oauth.ts-508-      if (pages.length === 0) {
--
src/services/instagram-oauth.ts-517-          );
src/services/instagram-oauth.ts-518-
src/services/instagram-oauth.ts-519-          if (igResponse.ok) {
src/services/instagram-oauth.ts:520:            const igData: any = await jsonAny(igResponse);
src/services/instagram-oauth.ts-521-            
src/services/instagram-oauth.ts-522-            if (igData.instagram_business_account) {
src/services/instagram-oauth.ts-523-              const igAccountId = igData.instagram_business_account.id;
--
src/services/instagram-oauth.ts-528-              );
src/services/instagram-oauth.ts-529-
src/services/instagram-oauth.ts-530-              if (accountResponse.ok) {
src/services/instagram-oauth.ts:531:                const accountData: any = await jsonAny(accountResponse);
src/services/instagram-oauth.ts-532-                
src/services/instagram-oauth.ts-533-                this.logger.info('✅ Found Instagram Business Account', { username: accountData.username });
src/services/instagram-oauth.ts-534-                
--
src/services/utility-messages.ts-69-export class UtilityMessagesService {
src/services/utility-messages.ts-70-  private pool!: Pool;
src/services/utility-messages.ts-71-  private config!: AppConfig;
src/services/utility-messages.ts:72:  private logger!: any;
src/services/utility-messages.ts-73-
src/services/utility-messages.ts-74-  constructor(private container?: DIContainer) {
src/services/utility-messages.ts-75-    if (container) {
--
src/services/notification-service.ts-10-export interface NotificationPayload {
src/services/notification-service.ts-11-  type: string;
src/services/notification-service.ts-12-  recipient: string;
src/services/notification-service.ts:13:  content: any;
src/services/notification-service.ts-14-}
src/services/notification-service.ts-15-
src/services/notification-service.ts-16-export interface NotificationResult {
--
src/services/health-check.ts-38-    );
src/services/health-check.ts-39-    
src/services/health-check.ts-40-    return result.ok ? result.result : { ok: false, error: result.reason };
src/services/health-check.ts:41:  } catch (error: any) {
src/services/health-check.ts-42-    return { ok: false, error: error.message };
src/services/health-check.ts-43-  }
src/services/health-check.ts-44-}
--
src/services/health-check.ts-47-  const details: Record<string, unknown> = {};
src/services/health-check.ts-48-  const redis = await redisHealthProbe().catch((e) => ({ ok: false, error: e.message }));
src/services/health-check.ts-49-  details.redis = redis;
src/services/health-check.ts:50:  const ok = (redis as any).ok === true;
src/services/health-check.ts-51-  return {
src/services/health-check.ts-52-    ready: ok,
src/services/health-check.ts-53-    status: ok ? 'ok' : 'degraded',
--
src/services/health-check.ts-59-export function startHealth(refreshMs = 2000) {
src/services/health-check.ts-60-  if (timer) return;
src/services/health-check.ts-61-  const tick = async () => {
src/services/health-check.ts:62:    try { snapshot = await compute(); } catch (e: any) {
src/services/health-check.ts-63-      snapshot = { ready: false, status: 'degraded', lastUpdated: Date.now(), details: { error: e?.message } };
src/services/health-check.ts-64-    }
src/services/health-check.ts-65-  };
src/services/health-check.ts-66-  void tick();
src/services/health-check.ts-67-  timer = setInterval(tick, refreshMs);
src/services/health-check.ts-68-  // make interval unref to not block process exit on Render
src/services/health-check.ts:69:  (timer as any).unref?.();
src/services/health-check.ts-70-}
src/services/health-check.ts-71-
src/services/health-check.ts-72-export function stopHealth() {
--
src/startup/migrate.ts-94-/**
src/startup/migrate.ts-95- * Seeds initial data (merchant and page mapping)
src/startup/migrate.ts-96- */
src/startup/migrate.ts:97:async function seedInitialData(client: any): Promise<void> {
src/startup/migrate.ts-98-  // Get configuration from environment
src/startup/migrate.ts-99-  const merchantId = requireMerchantId();
src/startup/migrate.ts-100-  const merchantName = process.env.MERCHANT_NAME;
--
src/services/instagram-comments-manager.test.ts-16-  transaction: mock()
src/services/instagram-comments-manager.test.ts-17-};
src/services/instagram-comments-manager.test.ts-18-
src/services/instagram-comments-manager.test.ts:19:const mockSQL = mock((strings: TemplateStringsArray, ...values: any[]) => {
src/services/instagram-comments-manager.test.ts-20-  const query = strings.join('?');
src/services/instagram-comments-manager.test.ts-21-  return Promise.resolve([
src/services/instagram-comments-manager.test.ts-22-    {
--
src/services/instagram-comments-manager.test.ts-103-}));
src/services/instagram-comments-manager.test.ts-104-
src/services/instagram-comments-manager.test.ts-105-mock.module('../middleware/idempotency.js', () => ({
src/services/instagram-comments-manager.test.ts:106:  hashMerchantAndBody: mock((merchantId: string, body: any) => `hash-${merchantId}-${JSON.stringify(body).length}`)
src/services/instagram-comments-manager.test.ts-107-}));
src/services/instagram-comments-manager.test.ts-108-
src/services/instagram-comments-manager.test.ts-109-mock.module('../utils/expiring-map.js', () => ({
--
src/repositories/message-repository.ts-214-  async update(id: string, data: UpdateMessageRequest): Promise<Message | null> {
src/repositories/message-repository.ts-215-    const sql: Sql = this.db.getSQL();
src/repositories/message-repository.ts-216-    const fields: string[] = [];
src/repositories/message-repository.ts:217:    const params: any[] = [];
src/repositories/message-repository.ts-218-    let i = 1;
src/repositories/message-repository.ts-219-
src/repositories/message-repository.ts-220-    if (data.deliveryStatus !== undefined) { fields.push(`delivery_status = $${i++}`); params.push(data.deliveryStatus); }
--
src/repositories/message-repository.ts-240-  async findMany(filters: MessageFilters = {}): Promise<Message[]> {
src/repositories/message-repository.ts-241-    const sql: Sql = this.db.getSQL();
src/repositories/message-repository.ts-242-    const where: string[] = [];
src/repositories/message-repository.ts:243:    const params: any[] = [];
src/repositories/message-repository.ts-244-    let i = 1;
src/repositories/message-repository.ts-245-
src/repositories/message-repository.ts-246-    if (filters.conversationId) { where.push(`conversation_id = $${i++}::uuid`); params.push(filters.conversationId); }
--
src/repositories/message-repository.ts-368-  ): Promise<MessageStats> {
src/repositories/message-repository.ts-369-    const sql: Sql = this.db.getSQL();
src/repositories/message-repository.ts-370-    const where: string[] = [];
src/repositories/message-repository.ts:371:    const params: any[] = [];
src/repositories/message-repository.ts-372-    let i = 1;
src/repositories/message-repository.ts-373-    if (conversationId) { where.push(`conversation_id = $${i++}::uuid`); params.push(conversationId); }
src/repositories/message-repository.ts-374-    if (dateFrom)       { where.push(`created_at >= $${i++}`);           params.push(dateFrom); }
--
src/repositories/message-repository.ts-468-  async count(filters: MessageFilters = {}): Promise<number> {
src/repositories/message-repository.ts-469-    const sql: Sql = this.db.getSQL();
src/repositories/message-repository.ts-470-    const where: string[] = [];
src/repositories/message-repository.ts:471:    const params: any[] = [];
src/repositories/message-repository.ts-472-    let i = 1;
src/repositories/message-repository.ts-473-    if (filters.conversationId) { where.push(`conversation_id = $${i++}::uuid`); params.push(filters.conversationId); }
src/repositories/message-repository.ts-474-    if (filters.direction)      { where.push(`direction = $${i++}`);             params.push(filters.direction); }
--
src/services/instagram-messaging.ts-92-    merchantId: string,
src/services/instagram-messaging.ts-93-    igUserId: string,
src/services/instagram-messaging.ts-94-    accessToken: string,
src/services/instagram-messaging.ts:95:    messagePayload: any
src/services/instagram-messaging.ts-96-  ): Promise<any> {
src/services/instagram-messaging.ts-97-    const url = `${GRAPH_API_BASE_URL}/${igUserId}/messages`;
src/services/instagram-messaging.ts-98-    const rateKey = `ig:${merchantId}:${igUserId}:messages`;
--
src/services/instagram-messaging.ts-115-          rateKey
src/services/instagram-messaging.ts-116-        );
src/services/instagram-messaging.ts-117-
src/services/instagram-messaging.ts:118:        const data: any = await response.json();
src/services/instagram-messaging.ts-119-        if (!response.ok) {
src/services/instagram-messaging.ts-120-          logger.error('❌ Instagram message send failed', data);
src/services/instagram-messaging.ts-121-          throw new Error(data.error?.message || 'Unknown error');
--
src/services/instagram-messaging.ts-213-      };
src/services/instagram-messaging.ts-214-
src/services/instagram-messaging.ts-215-      // Send message via Instagram Graph API with rate limiter
src/services/instagram-messaging.ts:216:      const responseData: any = await this.sendGraphMessage(
src/services/instagram-messaging.ts-217-        merchantId,
src/services/instagram-messaging.ts-218-        igUserId,
src/services/instagram-messaging.ts-219-        accessToken,
--
src/services/instagram-messaging.ts-318-        };
src/services/instagram-messaging.ts-319-
src/services/instagram-messaging.ts-320-      // Send message via Instagram Graph API with rate limiter
src/services/instagram-messaging.ts:321:      const responseData: any = await this.sendGraphMessage(
src/services/instagram-messaging.ts-322-        merchantId,
src/services/instagram-messaging.ts-323-        igUserId,
src/services/instagram-messaging.ts-324-        accessToken,
--
src/services/instagram-messaging.ts-434-      };
src/services/instagram-messaging.ts-435-
src/services/instagram-messaging.ts-436-      // Send message via Instagram Graph API with rate limiter
src/services/instagram-messaging.ts:437:      const responseData: any = await this.sendGraphMessage(
src/services/instagram-messaging.ts-438-        merchantId,
src/services/instagram-messaging.ts-439-        igUserId,
src/services/instagram-messaging.ts-440-        accessToken,
--
src/services/instagram-messaging.ts-490-    try {
src/services/instagram-messaging.ts-491-      const sql = this.db.getSQL();
src/services/instagram-messaging.ts-492-
src/services/instagram-messaging.ts:493:      const result: any[] = await sql`
src/services/instagram-messaging.ts-494-        SELECT instagram_token_encrypted, token_expires_at
src/services/instagram-messaging.ts-495-        FROM merchant_credentials
src/services/instagram-messaging.ts-496-        WHERE merchant_id = ${merchantId}::uuid
--
src/services/instagram-messaging.ts-542-    try {
src/services/instagram-messaging.ts-543-      const sql = this.db.getSQL();
src/services/instagram-messaging.ts-544-
src/services/instagram-messaging.ts:545:      const result: any[] = await sql`
src/services/instagram-messaging.ts-546-        SELECT instagram_user_id
src/services/instagram-messaging.ts-547-        FROM merchant_credentials
src/services/instagram-messaging.ts-548-        WHERE merchant_id = ${merchantId}::uuid
--
src/services/instagram-messaging.ts-565-      const sql = this.db.getSQL();
src/services/instagram-messaging.ts-566-
src/services/instagram-messaging.ts-567-      // Get the latest incoming message from this recipient
src/services/instagram-messaging.ts:568:      const result: any[] = await sql`
src/services/instagram-messaging.ts-569-        SELECT
src/services/instagram-messaging.ts-570-          c.id as conversation_id,
src/services/instagram-messaging.ts-571-          MAX(ml.created_at) as last_message_time
--
src/services/instagram-messaging.ts-618-    recipientId: string,
src/services/instagram-messaging.ts-619-    content: string,
src/services/instagram-messaging.ts-620-    messageId: string,
src/services/instagram-messaging.ts:621:    options: any
src/services/instagram-messaging.ts-622-  ): Promise<void> {
src/services/instagram-messaging.ts-623-    try {
src/services/instagram-messaging.ts-624-      const sql = this.db.getSQL();
--
src/services/instagram-messaging.ts-669-    recipientId: string,
src/services/instagram-messaging.ts-670-    content: string,
src/services/instagram-messaging.ts-671-    errorMessage: string,
src/services/instagram-messaging.ts:672:    options: any
src/services/instagram-messaging.ts-673-  ): Promise<void> {
src/services/instagram-messaging.ts-674-    try {
src/services/instagram-messaging.ts-675-      const sql = this.db.getSQL();
--
src/services/monitoring.ts-114-   */
src/services/monitoring.ts-115-  public async checkWhatsAppQuality(merchantId: string): Promise<QualityCheck> {
src/services/monitoring.ts-116-    try {
src/services/monitoring.ts:117:      const sql = this.db.getSQL() as any;
src/services/monitoring.ts-118-      
src/services/monitoring.ts-119-      // Get recent metrics for the merchant
src/services/monitoring.ts-120-      const metrics = await this.calculateQualityMetrics(merchantId, 'whatsapp');
--
src/services/monitoring.ts-202-   */
src/services/monitoring.ts-203-  public async logPerformanceMetrics(metrics: PerformanceMetrics): Promise<void> {
src/services/monitoring.ts-204-    try {
src/services/monitoring.ts:205:      const sql = this.db.getSQL() as any;
src/services/monitoring.ts-206-      
src/services/monitoring.ts-207-      await sql`
src/services/monitoring.ts-208-        INSERT INTO audit_logs (
--
src/services/monitoring.ts-286-    responseRate: number;
src/services/monitoring.ts-287-  }>> {
src/services/monitoring.ts-288-    try {
src/services/monitoring.ts:289:      const sql = this.db.getSQL() as any;
src/services/monitoring.ts-290-
src/services/monitoring.ts-291-      const trends = await sql<QualityTrendRow[]>
src/services/monitoring.ts-292-      `
--
src/services/monitoring.ts-402-    // Database health check
src/services/monitoring.ts-403-    try {
src/services/monitoring.ts-404-      const start = Date.now();
src/services/monitoring.ts:405:      const sql = this.db.getSQL() as any;
src/services/monitoring.ts-406-      await sql`SELECT 1`;
src/services/monitoring.ts-407-      const responseTime = Date.now() - start;
src/services/monitoring.ts-408-      
--
src/services/monitoring.ts-413-      });
src/services/monitoring.ts-414-      
src/services/monitoring.ts-415-      telemetry.recordDatabaseQuery('health_check', true, responseTime);
src/services/monitoring.ts:416:    } catch (error: any) {
src/services/monitoring.ts-417-      services.push({
src/services/monitoring.ts-418-        name: 'database',
src/services/monitoring.ts-419-        status: 'down' as const,
--
src/services/monitoring.ts-431-        status: 'up' as const,
src/services/monitoring.ts-432-        responseTime: 5 // Mock for now
src/services/monitoring.ts-433-      });
src/services/monitoring.ts:434:    } catch (error: any) {
src/services/monitoring.ts-435-      services.push({
src/services/monitoring.ts-436-        name: 'redis',
src/services/monitoring.ts-437-        status: 'down' as const,
--
src/services/monitoring.ts-475-    memoryUsage: number;
src/services/monitoring.ts-476-  }> {
src/services/monitoring.ts-477-    try {
src/services/monitoring.ts:478:      const sql = this.db.getSQL() as any;
src/services/monitoring.ts-479-      
src/services/monitoring.ts-480-      const performance = await sql<SystemPerformanceRow[]>
src/services/monitoring.ts-481-      `
--
src/services/monitoring.ts-529-   */
src/services/monitoring.ts-530-  private async calculateQualityMetrics(merchantId: string, platform: Platform): Promise<any> {
src/services/monitoring.ts-531-    try {
src/services/monitoring.ts:532:      const sql = this.db.getSQL() as any;
src/services/monitoring.ts-533-      
src/services/monitoring.ts-534-      const stats = await sql<QualityStatsRow[]>
src/services/monitoring.ts-535-      `
--
src/services/monitoring.ts-594-  /**
src/services/monitoring.ts-595-   * Private: Determine quality status based on metrics
src/services/monitoring.ts-596-   */
src/services/monitoring.ts:597:  private determineQualityStatus(metrics: any): QualityStatus {
src/services/monitoring.ts-598-    const qualityRating = metrics.qualityRating || 0;
src/services/monitoring.ts-599-    
src/services/monitoring.ts-600-    if (qualityRating >= 0.9) return 'EXCELLENT';
--
src/services/monitoring.ts-607-  /**
src/services/monitoring.ts-608-   * Private: Generate recommendations based on metrics
src/services/monitoring.ts-609-   */
src/services/monitoring.ts:610:  private generateRecommendations(metrics: any, status: QualityStatus): string[] {
src/services/monitoring.ts-611-    const recommendations: string[] = [];
src/services/monitoring.ts-612-    
src/services/monitoring.ts-613-    if (metrics.responseRate24h < 0.8) {
--
src/services/monitoring.ts-633-  /**
src/services/monitoring.ts-634-   * Private: Generate alerts based on metrics
src/services/monitoring.ts-635-   */
src/services/monitoring.ts:636:  private generateAlerts(metrics: any, status: QualityStatus): QualityAlert[] {
src/services/monitoring.ts-637-    const alerts: QualityAlert[] = [];
src/services/monitoring.ts-638-    
src/services/monitoring.ts-639-    if (status === 'CRITICAL') {
--
src/services/monitoring.ts-672-  private async storeQualityMetrics(
src/services/monitoring.ts-673-    merchantId: string,
src/services/monitoring.ts-674-    platform: Platform,
src/services/monitoring.ts:675:    metrics: any,
src/services/monitoring.ts-676-    status: QualityStatus
src/services/monitoring.ts-677-  ): Promise<void> {
src/services/monitoring.ts-678-    try {
src/services/monitoring.ts:679:      const sql = this.db.getSQL() as any;
src/services/monitoring.ts-680-      
src/services/monitoring.ts-681-      await sql`
src/services/monitoring.ts-682-        INSERT INTO quality_metrics (
--
src/services/monitoring.ts-761-        event: 'sendQualityAlert'
src/services/monitoring.ts-762-      });
src/services/monitoring.ts-763-      
src/services/monitoring.ts:764:      const sql = this.db.getSQL() as any;
src/services/monitoring.ts-765-      
src/services/monitoring.ts-766-      for (const alert of alerts) {
src/services/monitoring.ts-767-        await sql`
--
src/services/monitoring.ts-800- * Real-time monitoring middleware for API endpoints
src/services/monitoring.ts-801- */
src/services/monitoring.ts-802-export function createPerformanceMiddleware(monitoringService: MonitoringService) {
src/services/monitoring.ts:803:  return (req: any, res: any, next: any) => {
src/services/monitoring.ts-804-    const startTime = Date.now();
src/services/monitoring.ts-805-    const originalEnd = res.end;
src/services/monitoring.ts-806-
src/services/monitoring.ts:807:    res.end = function(...args: any[]) {
src/services/monitoring.ts-808-      const responseTime = Date.now() - startTime;
src/services/monitoring.ts-809-      const metrics: PerformanceMetrics = {
src/services/monitoring.ts-810-        endpoint: req.path || req.url,
--
src/services/utility-messages.test.ts-52-describe('📱 Utility Messages Service Tests', () => {
src/services/utility-messages.test.ts-53-  let utilityMessagesService: UtilityMessagesService;
src/services/utility-messages.test.ts-54-  let mockSQL: jest.Mock;
src/services/utility-messages.test.ts:55:  let mockInstagramClient: any;
src/services/utility-messages.test.ts:56:  let mockLogger: any;
src/services/utility-messages.test.ts-57-
src/services/utility-messages.test.ts-58-  const sampleMerchantId = 'merchant-123';
src/services/utility-messages.test.ts-59-  const sampleTemplateId = 'template-456';
--
src/services/utility-messages.test.ts-546-
src/services/utility-messages.test.ts-547-  describe('Template Interpolation', () => {
src/services/utility-messages.test.ts-548-    test('✅ should interpolate simple variables', () => {
src/services/utility-messages.test.ts:549:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-550-      const result = service.interpolateTemplate(
src/services/utility-messages.test.ts-551-        'Hello {{name}}, your order {{id}} is ready',
src/services/utility-messages.test.ts-552-        { name: 'Ahmed', id: '123' }
--
src/services/utility-messages.test.ts-556-    });
src/services/utility-messages.test.ts-557-
src/services/utility-messages.test.ts-558-    test('✅ should handle multiple occurrences of same variable', () => {
src/services/utility-messages.test.ts:559:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-560-      const result = service.interpolateTemplate(
src/services/utility-messages.test.ts-561-        '{{name}} ordered {{item}}, {{name}} paid {{amount}}',
src/services/utility-messages.test.ts-562-        { name: 'Sara', item: 'phone', amount: '500' }
--
src/services/utility-messages.test.ts-566-    });
src/services/utility-messages.test.ts-567-
src/services/utility-messages.test.ts-568-    test('✅ should handle special characters in variables', () => {
src/services/utility-messages.test.ts:569:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-570-      const result = service.interpolateTemplate(
src/services/utility-messages.test.ts-571-        'Order {{order_id}} total: {{amount}}',
src/services/utility-messages.test.ts-572-        { order_id: 'ORD-2024/01/15-001', amount: '$100.50' }
--
src/services/utility-messages.test.ts-576-    });
src/services/utility-messages.test.ts-577-
src/services/utility-messages.test.ts-578-    test('✅ should handle Arabic content and variables', () => {
src/services/utility-messages.test.ts:579:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-580-      const result = service.interpolateTemplate(
src/services/utility-messages.test.ts-581-        'مرحباً {{اسم_العميل}}، طلبك رقم {{رقم_الطلب}} جاهز',
src/services/utility-messages.test.ts-582-        { 'اسم_العميل': 'أحمد', 'رقم_الطلب': '٧٨٩' }
--
src/services/utility-messages.test.ts-586-    });
src/services/utility-messages.test.ts-587-
src/services/utility-messages.test.ts-588-    test('✅ should leave unmatched variables unchanged', () => {
src/services/utility-messages.test.ts:589:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-590-      const result = service.interpolateTemplate(
src/services/utility-messages.test.ts-591-        'Hello {{name}}, order {{id}}, reference {{ref}}',
src/services/utility-messages.test.ts-592-        { name: 'Ahmed', id: '123' }
--
src/services/utility-messages.test.ts-596-    });
src/services/utility-messages.test.ts-597-
src/services/utility-messages.test.ts-598-    test('✅ should handle empty variables object', () => {
src/services/utility-messages.test.ts:599:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-600-      const result = service.interpolateTemplate(
src/services/utility-messages.test.ts-601-        'Template with {{variables}}',
src/services/utility-messages.test.ts-602-        {}
--
src/services/utility-messages.test.ts-608-
src/services/utility-messages.test.ts-609-  describe('Marketing Content Detection', () => {
src/services/utility-messages.test.ts-610-    test('❌ should detect English marketing keywords', () => {
src/services/utility-messages.test.ts:611:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-612-      
src/services/utility-messages.test.ts-613-      const marketingPhrases = [
src/services/utility-messages.test.ts-614-        'Special sale this weekend!',
--
src/services/utility-messages.test.ts-624-    });
src/services/utility-messages.test.ts-625-
src/services/utility-messages.test.ts-626-    test('❌ should detect Arabic marketing keywords', () => {
src/services/utility-messages.test.ts:627:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-628-      
src/services/utility-messages.test.ts-629-      const marketingPhrases = [
src/services/utility-messages.test.ts-630-        'خصم كبير اليوم!',
--
src/services/utility-messages.test.ts-639-    });
src/services/utility-messages.test.ts-640-
src/services/utility-messages.test.ts-641-    test('✅ should allow transactional content', () => {
src/services/utility-messages.test.ts:642:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-643-      
src/services/utility-messages.test.ts-644-      const transactionalPhrases = [
src/services/utility-messages.test.ts-645-        'تأكيد طلبك رقم 123',
--
src/services/utility-messages.test.ts-655-    });
src/services/utility-messages.test.ts-656-
src/services/utility-messages.test.ts-657-    test('✅ should be case insensitive', () => {
src/services/utility-messages.test.ts:658:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-659-      
src/services/utility-messages.test.ts-660-      expect(service.containsMarketingContent('SALE TODAY')).toBe(true);
src/services/utility-messages.test.ts-661-      expect(service.containsMarketingContent('Sale Today')).toBe(true);
--
src/services/utility-messages.test.ts-673-
src/services/utility-messages.test.ts-674-    test('✅ should create instance if not exists', () => {
src/services/utility-messages.test.ts-675-      // Reset singleton
src/services/utility-messages.test.ts:676:      (require('./utility-messages.js') as any).utilityMessagesServiceInstance = null;
src/services/utility-messages.test.ts-677-
src/services/utility-messages.test.ts-678-      const instance = getUtilityMessagesService();
src/services/utility-messages.test.ts-679-      expect(instance).toBeInstanceOf(UtilityMessagesService);
--
src/services/utility-messages.test.ts-742-
src/services/utility-messages.test.ts-743-  describe('Edge Cases', () => {
src/services/utility-messages.test.ts-744-    test('✅ should handle null/undefined variables', () => {
src/services/utility-messages.test.ts:745:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-746-      const result = service.interpolateTemplate(
src/services/utility-messages.test.ts-747-        'Hello {{name}}',
src/services/utility-messages.test.ts-748-        { name: null }
--
src/services/utility-messages.test.ts-752-    });
src/services/utility-messages.test.ts-753-
src/services/utility-messages.test.ts-754-    test('✅ should handle empty template content', () => {
src/services/utility-messages.test.ts:755:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-756-      const result = service.interpolateTemplate('', { any: 'value' });
src/services/utility-messages.test.ts-757-
src/services/utility-messages.test.ts-758-      expect(result).toBe('');
src/services/utility-messages.test.ts-759-    });
src/services/utility-messages.test.ts-760-
src/services/utility-messages.test.ts-761-    test('✅ should handle templates with no variables', () => {
src/services/utility-messages.test.ts:762:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-763-      const result = service.interpolateTemplate(
src/services/utility-messages.test.ts-764-        'Static message content',
src/services/utility-messages.test.ts-765-        { unused: 'variable' }
--
src/services/utility-messages.test.ts-769-    });
src/services/utility-messages.test.ts-770-
src/services/utility-messages.test.ts-771-    test('✅ should handle malformed template variables', () => {
src/services/utility-messages.test.ts:772:      const service = utilityMessagesService as any;
src/services/utility-messages.test.ts-773-      const result = service.interpolateTemplate(
src/services/utility-messages.test.ts-774-        'Bad format {name} and {{incomplete',
src/services/utility-messages.test.ts-775-        { name: 'Ahmed' }
--
src/services/encryption.ts-65- * exceeds `maxBytes` (default 1MB), the reader is cancelled and an
src/services/encryption.ts-66- * HTTP 413 error is thrown.
src/services/encryption.ts-67- */
src/services/encryption.ts:68:export async function readRawBody(c: any, maxBytes = 1024 * 1024): Promise<Buffer> {
src/services/encryption.ts-69-  const r = c.req.raw.body;
src/services/encryption.ts-70-  if (!r) return Buffer.alloc(0);
src/services/encryption.ts-71-  const reader = r.getReader();
--
src/types/instagram.ts-82-  recipientId: string;
src/types/instagram.ts-83-  messageType: 'text' | 'image' | 'template';
src/types/instagram.ts-84-  content: string;
src/types/instagram.ts:85:  attachment?: { type: string; payload: any };
src/types/instagram.ts-86-  quickReplies?: QuickReply[];
src/types/instagram.ts-87-}
--
src/types/postgres-extensions.d.ts-1-declare module 'postgres' {
src/types/postgres-extensions.d.ts-2-  // Extension for postgres library if needed in future
src/types/postgres-extensions.d.ts-3-  interface Sql<TTypes extends Record<string, unknown> = {}> {
src/types/postgres-extensions.d.ts:4:    join(values: any[], separator: any): Sql<TTypes>;
src/types/postgres-extensions.d.ts-5-  }
src/types/postgres-extensions.d.ts-6-}
src/types/postgres-extensions.d.ts-7-
--
src/services/instagram-api.ts-102-
src/services/instagram-api.ts-103-export class InstagramAPIClient {
src/services/instagram-api.ts-104-  private readonly baseUrl = GRAPH_API_BASE_URL;
src/services/instagram-api.ts:105:  private encryptionService: any;
src/services/instagram-api.ts-106-  private pool: Pool;
src/services/instagram-api.ts:107:  private rateLimiter: any;
src/services/instagram-api.ts:108:  private logger: any;
src/services/instagram-api.ts-109-  private config: AppConfig;
src/services/instagram-api.ts-110-
src/services/instagram-api.ts-111-  private credentials: InstagramAPICredentials | null = null;
--
src/services/instagram-api.ts-126-      
src/services/instagram-api.ts-127-      this.encryptionService = getEncryptionService();
src/services/instagram-api.ts-128-      this.rateLimiter = getMetaRateLimiter();
src/services/instagram-api.ts:129:    } catch (error: any) {
src/services/instagram-api.ts-130-      this.logger.error('Failed to initialize InstagramAPIClient dependencies:', error);
src/services/instagram-api.ts-131-      throw error;
src/services/instagram-api.ts-132-    }
--
src/services/instagram-api.ts-221-      if (!res.ok) {
src/services/instagram-api.ts-222-        const errBody = await res.text().catch(() => '');
src/services/instagram-api.ts-223-        const e = new Error(`IG Graph error ${res.status}: ${errBody}`);
src/services/instagram-api.ts:224:        (e as any).status = res.status;
src/services/instagram-api.ts-225-        throw e;
src/services/instagram-api.ts-226-      }
src/services/instagram-api.ts-227-
--
src/services/instagram-api.ts-253-
src/services/instagram-api.ts-254-      const rateLimitRemaining =
src/services/instagram-api.ts-255-        this.parseRateLimitHeaders(response) ?? 200;
src/services/instagram-api.ts:256:      const result: any = await response.json();
src/services/instagram-api.ts-257-
src/services/instagram-api.ts-258-      return {
src/services/instagram-api.ts-259-        success: true,
--
src/services/instagram-api.ts-262-      };
src/services/instagram-api.ts-263-    } catch (error) {
src/services/instagram-api.ts-264-      this.logger.error('❌ Instagram message send failed:', error);
src/services/instagram-api.ts:265:      const status = typeof (error as any)?.status === 'number'
src/services/instagram-api.ts:266:        ? (error as any).status
src/services/instagram-api.ts-267-        : 500;
src/services/instagram-api.ts:268:      const message = typeof (error as any)?.message === 'string'
src/services/instagram-api.ts:269:        ? (error as any).message
src/services/instagram-api.ts-270-        : 'Unknown error';
src/services/instagram-api.ts-271-      return {
src/services/instagram-api.ts-272-        success: false,
--
src/services/instagram-api.ts-331-      throw new Error(errText);
src/services/instagram-api.ts-332-    }
src/services/instagram-api.ts-333-
src/services/instagram-api.ts:334:    const data: any = await response.json().catch(() => ({}));
src/services/instagram-api.ts-335-    return data.id || data.media_id || data.attachment_id || data.mediaId;
src/services/instagram-api.ts-336-  }
src/services/instagram-api.ts-337-
--
src/services/instagram-api.ts-367-        message: message
src/services/instagram-api.ts-368-      };
src/services/instagram-api.ts-369-
src/services/instagram-api.ts:370:      const result: any = await this.graphRequest<any>(
src/services/instagram-api.ts-371-        'POST',
src/services/instagram-api.ts-372-        `/${commentId}/replies`,
src/services/instagram-api.ts-373-        credentials.pageAccessToken,
--
src/services/instagram-api.ts-475-        verify_token: credentials.webhookVerifyToken
src/services/instagram-api.ts-476-      };
src/services/instagram-api.ts-477-
src/services/instagram-api.ts:478:      const result: any = await this.graphRequest<any>(
src/services/instagram-api.ts-479-        'POST',
src/services/instagram-api.ts-480-        `/${credentials.pageId}/subscribed_apps`,
src/services/instagram-api.ts-481-        credentials.pageAccessToken,
--
src/services/instagram-api.ts-618-  /**
src/services/instagram-api.ts-619-   * Private: Build message payload for API
src/services/instagram-api.ts-620-   */
src/services/instagram-api.ts:621:  private buildMessagePayload(request: SendMessageRequest): any {
src/services/instagram-api.ts-622-    const basePayload = {
src/services/instagram-api.ts-623-      recipient: {
src/services/instagram-api.ts-624-        id: request.recipientId
--
src/services/instagram-api.ts-679- * Instagram Credentials Manager
src/services/instagram-api.ts-680- */
src/services/instagram-api.ts-681-export class InstagramAPICredentialsManager {
src/services/instagram-api.ts:682:  private encryptionService: any;
src/services/instagram-api.ts-683-  private pool: Pool;
src/services/instagram-api.ts:684:  private logger: any;
src/services/instagram-api.ts-685-  private config: AppConfig;
src/services/instagram-api.ts-686-
src/services/instagram-api.ts-687-  constructor(private container: DIContainer) {
--
src/services/instagram-api.ts-696-    try {
src/services/instagram-api.ts-697-      const { getEncryptionService } = await import('./encryption.js');
src/services/instagram-api.ts-698-      this.encryptionService = getEncryptionService();
src/services/instagram-api.ts:699:    } catch (error: any) {
src/services/instagram-api.ts-700-      this.logger.error('Failed to initialize InstagramAPICredentialsManager dependencies:', error);
src/services/instagram-api.ts-701-      throw error;
src/services/instagram-api.ts-702-    }
--
src/services/instagram-api.ts-820-      const { getDatabase } = await import('../db/adapter.js');
src/services/instagram-api.ts-821-      const sql = getDatabase().getSQL();
src/services/instagram-api.ts-822-      
src/services/instagram-api.ts:823:      const result: any[] = await sql`
src/services/instagram-api.ts-824-        SELECT instagram_token_encrypted
src/services/instagram-api.ts-825-        FROM merchant_credentials
src/services/instagram-api.ts-826-        WHERE merchant_id = ${merchantId}::uuid
--
src/services/instagram-api.ts-848-      const { getDatabase } = await import('../db/adapter.js');
src/services/instagram-api.ts-849-      const db = getDatabase();
src/services/instagram-api.ts-850-      
src/services/instagram-api.ts:851:      const result: any[] = await query(db.getPool(), `
src/services/instagram-api.ts-852-        SELECT
src/services/instagram-api.ts-853-          instagram_token_encrypted,
src/services/instagram-api.ts-854-          instagram_page_id,
--
src/services/instagram-message-sender.ts-18-import type { QuickReply, SendMessageRequest } from '../types/instagram.js';
src/services/instagram-message-sender.ts-19-
src/services/instagram-message-sender.ts-20-interface SendMessageWithAttachment extends Omit<SendMessageRequest, 'messageType' | 'content'> {
src/services/instagram-message-sender.ts:21:  attachment: { type: string; payload: any };
src/services/instagram-message-sender.ts-22-  content?: string;
src/services/instagram-message-sender.ts-23-  messageType?: SendMessageRequest['messageType'];
src/services/instagram-message-sender.ts-24-}
--
src/services/instagram-message-sender.ts-747-  /**
src/services/instagram-message-sender.ts-748-   * Private: Convert template to Instagram format
src/services/instagram-message-sender.ts-749-   */
src/services/instagram-message-sender.ts:750:  private convertToInstagramTemplate(template: MessageTemplate): any {
src/services/instagram-message-sender.ts-751-    // Convert our template format to Instagram's expected format
src/services/instagram-message-sender.ts-752-    return {
src/services/instagram-message-sender.ts-753-      template_type: template.type,
--
src/services/instagram-message-sender.ts-796-    message: string,
src/services/instagram-message-sender.ts-797-    result: SendResult,
src/services/instagram-message-sender.ts-798-    conversationId?: string,
src/services/instagram-message-sender.ts:799:    metadata?: any
src/services/instagram-message-sender.ts-800-  ): Promise<void> {
src/services/instagram-message-sender.ts-801-    try {
src/services/instagram-message-sender.ts-802-      const sql = this.db.getSQL();
--
src/services/instagram-message-sender.ts-908-    sent: number,
src/services/instagram-message-sender.ts-909-    failed: number,
src/services/instagram-message-sender.ts-910-    message: string,
src/services/instagram-message-sender.ts:911:    metadata?: any
src/services/instagram-message-sender.ts-912-  ): Promise<void> {
src/services/instagram-message-sender.ts-913-    try {
src/services/instagram-message-sender.ts-914-      const sql = this.db.getSQL();
--
src/services/UpstashQuotaMonitor.ts-19-  private thresholds: [number, number];
src/services/UpstashQuotaMonitor.ts-20-
src/services/UpstashQuotaMonitor.ts-21-  constructor(
src/services/UpstashQuotaMonitor.ts:22:    private logger: any,
src/services/UpstashQuotaMonitor.ts-23-    options?: {
src/services/UpstashQuotaMonitor.ts-24-      restUrl?: string;
src/services/UpstashQuotaMonitor.ts-25-      restToken?: string;
--
src/services/UpstashQuotaMonitor.ts-47-        throw new Error(`HTTP ${response.status}`);
src/services/UpstashQuotaMonitor.ts-48-      }
src/services/UpstashQuotaMonitor.ts-49-
src/services/UpstashQuotaMonitor.ts:50:      const data: any = await response.json();
src/services/UpstashQuotaMonitor.ts-51-      const used = Number(data?.requests ?? data?.usage?.requests ?? 0);
src/services/UpstashQuotaMonitor.ts-52-      const limit = Number(data?.limit ?? data?.usage?.limit ?? 1);
src/services/UpstashQuotaMonitor.ts-53-      return { used, limit, percentage: used / limit };
--
src/repositories/merchant-repository.ts-257-
src/repositories/merchant-repository.ts-258-    const [merchant] = await sql<MerchantRow>`
src/repositories/merchant-repository.ts-259-      UPDATE merchants
src/repositories/merchant-repository.ts:260:      SET ${(sql as any).join(updateFields, sql`, `)}
src/repositories/merchant-repository.ts-261-      WHERE id = ${id}::uuid
src/repositories/merchant-repository.ts-262-      RETURNING *
src/repositories/merchant-repository.ts-263-    `;
--
src/repositories/merchant-repository.ts-370-    }
src/repositories/merchant-repository.ts-371-
src/repositories/merchant-repository.ts-372-    const whereClause = conditions.length
src/repositories/merchant-repository.ts:373:      ? sql`WHERE ${(sql as any).join(conditions, sql` AND `)}`
src/repositories/merchant-repository.ts-374-      : sql``;
src/repositories/merchant-repository.ts-375-    const limitClause = filters.limit ? sql`LIMIT ${filters.limit}` : sql``;
src/repositories/merchant-repository.ts-376-    const offsetClause = filters.offset ? sql`OFFSET ${filters.offset}` : sql``;
--
src/repositories/merchant-repository.ts-379-    if (conditions.length > 0) {
src/repositories/merchant-repository.ts-380-      const merchants = await sql<MerchantRow>`
src/repositories/merchant-repository.ts-381-        SELECT * FROM merchants
src/repositories/merchant-repository.ts:382:        WHERE ${(sql as any).join(conditions, sql` AND `)}
src/repositories/merchant-repository.ts-383-        ORDER BY created_at DESC
src/repositories/merchant-repository.ts-384-        ${limitClause}
src/repositories/merchant-repository.ts-385-        ${offsetClause}
--
src/repositories/merchant-repository.ts-517-    }
src/repositories/merchant-repository.ts-518-
src/repositories/merchant-repository.ts-519-    const whereClause = conditions.length
src/repositories/merchant-repository.ts:520:      ? sql`WHERE ${(sql as any).join(conditions, sql` AND `)}`
src/repositories/merchant-repository.ts-521-      : sql``;
src/repositories/merchant-repository.ts-522-
src/repositories/merchant-repository.ts-523-    const rows = await sql<CountRow>`
--
src/services/monitoring.test.ts-59-  let monitoringService: MonitoringService;
src/services/monitoring.test.ts-60-  let metricsCollector: MetricsCollector;
src/services/monitoring.test.ts-61-  let alertManager: AlertManager;
src/services/monitoring.test.ts:62:  let db: any;
src/services/monitoring.test.ts:63:  let sql: any;
src/services/monitoring.test.ts-64-
src/services/monitoring.test.ts-65-  beforeAll(async () => {
src/services/monitoring.test.ts-66-    // Initialize database
--
src/services/encryption.test.ts-22-    const ctx = {
src/services/encryption.test.ts-23-      req: { raw: { body: stream } },
src/services/encryption.test.ts-24-      throw(status: number, message: string) {
src/services/encryption.test.ts:25:        const err: any = new Error(message);
src/services/encryption.test.ts-26-        err.status = status;
src/services/encryption.test.ts-27-        throw err;
src/services/encryption.test.ts-28-      }
--
src/database/migrate.ts-262-   * Create migrations table if it doesn't exist
src/database/migrate.ts-263-   */
src/database/migrate.ts-264-  public async createMigrationsTable(): Promise<void> {
src/database/migrate.ts:265:    const sql = this.db.getSQL() as any;
src/database/migrate.ts-266-    
src/database/migrate.ts-267-    await sql`
src/database/migrate.ts-268-      CREATE TABLE IF NOT EXISTS migrations (
--
src/database/migrate.ts-293-   * Get executed migrations from database
src/database/migrate.ts-294-   */
src/database/migrate.ts-295-  private async getExecutedMigrations(): Promise<Migration[]> {
src/database/migrate.ts:296:    const sql = this.db.getSQL() as any;
src/database/migrate.ts-297-    
src/database/migrate.ts-298-    try {
src/database/migrate.ts-299-      const migrations = await sql<Migration>`
--
src/database/migrate.ts-426-        const status = await getMigrationStatus();
src/database/migrate.ts-427-        console.log('📊 Migration Status:');
src/database/migrate.ts-428-        console.log(`Total: ${status.total}, Executed: ${status.executed}, Pending: ${status.pending}`);
src/database/migrate.ts:429:        status.migrations.forEach((m: any) => {
src/database/migrate.ts-430-          const indicator = m.status === 'executed' ? '✅' : '⏳';
src/database/migrate.ts-431-          console.log(`${indicator} ${m.name} (${m.filename})`);
src/database/migrate.ts-432-        });
--
src/services/instagram-api.test.ts-62-describe('📱 Instagram API Service Tests', () => {
src/services/instagram-api.test.ts-63-  let instagramClient: InstagramAPIClient;
src/services/instagram-api.test.ts-64-  let mockSQL: jest.Mock;
src/services/instagram-api.test.ts:65:  let mockLogger: any;
src/services/instagram-api.test.ts-66-  let mockFetch: jest.Mock;
src/services/instagram-api.test.ts-67-
src/services/instagram-api.test.ts-68-  const sampleCredentials = {
--
src/services/instagram-media-manager.ts-475-        LIMIT 5
src/services/instagram-media-manager.ts-476-      `;
src/services/instagram-media-manager.ts-477-
src/services/instagram-media-manager.ts:478:      const totalMedia = mediaStats.reduce((sum: number, stat: any) => sum + Number(((stat as unknown) as { type_count: string })?.type_count ?? 0), 0);
src/services/instagram-media-manager.ts:479:      const totalResponses = mediaStats.reduce((sum: number, stat: any) => sum + Number(((stat as unknown) as { responses: string })?.responses ?? 0), 0);
src/services/instagram-media-manager.ts-480-
src/services/instagram-media-manager.ts-481-      return {
src/services/instagram-media-manager.ts-482-        totalMediaMessages: totalMedia,
--
src/services/instagram-media-manager.ts-488-        mediaResponseRate: totalMedia > 0 ? (totalResponses / totalMedia) * 100 : 0,
src/services/instagram-media-manager.ts-489-        productInquiries: Number(((inquiryStats[0] as unknown) as { product_inquiries: string })?.product_inquiries || 0),
src/services/instagram-media-manager.ts-490-        averageEngagement: 75, // Could be calculated from detailed engagement metrics
src/services/instagram-media-manager.ts:491:        topMediaTemplates: templateStats.map((template: any) => ({
src/services/instagram-media-manager.ts-492-          name: ((template as unknown) as { name: string; usage_count: string; category: string })?.name ?? '',
src/services/instagram-media-manager.ts-493-          usageCount: Number(((template as unknown) as { name: string; usage_count: string; category: string })?.usage_count ?? 0),
src/services/instagram-media-manager.ts-494-          category: ((template as unknown) as { name: string; usage_count: string; category: string })?.category ?? ''
--
src/services/meta-rate-limiter.ts-261-          console.error(
src/services/meta-rate-limiter.ts-262-            `🚫 Meta rate limiter blocked request: ${rateKey} (remaining: ${check.remaining})`
src/services/meta-rate-limiter.ts-263-          );
src/services/meta-rate-limiter.ts:264:          const err: any = new Error('RATE_LIMIT_EXCEEDED');
src/services/meta-rate-limiter.ts-265-          err.code = 'RATE_LIMIT_EXCEEDED';
src/services/meta-rate-limiter.ts-266-          err.resetTime = check.resetTime;
src/services/meta-rate-limiter.ts-267-          throw err;
--
src/services/cross-platform-conversation-manager.ts-627-  /**
src/services/cross-platform-conversation-manager.ts-628-   * Private: Build unified context from multiple conversations
src/services/cross-platform-conversation-manager.ts-629-   */
src/services/cross-platform-conversation-manager.ts:630:  private async buildUnifiedContext(conversations: any[]): Promise<UnifiedConversationContext> {
src/services/cross-platform-conversation-manager.ts-631-    const contexts = conversations.map(c => CrossPlatformConversationManager.jsonParseSafe(c.session_data, {}));
src/services/cross-platform-conversation-manager.ts-632-    
src/services/cross-platform-conversation-manager.ts-633-    // Merge cart items from all platforms
src/services/cross-platform-conversation-manager.ts-634-    const allCartItems: CartItem[] = [];
src/services/cross-platform-conversation-manager.ts:635:    contexts.forEach((ctx: any, index) => {
src/services/cross-platform-conversation-manager.ts-636-      if (ctx.cart && Array.isArray(ctx.cart)) {
src/services/cross-platform-conversation-manager.ts:637:        ctx.cart.forEach((item: any) => {
src/services/cross-platform-conversation-manager.ts-638-          allCartItems.push({
src/services/cross-platform-conversation-manager.ts-639-            ...item,
src/services/cross-platform-conversation-manager.ts-640-            platform: conversations[index].platform,
--
src/services/cross-platform-conversation-manager.ts-645-    });
src/services/cross-platform-conversation-manager.ts-646-
src/services/cross-platform-conversation-manager.ts-647-    // Merge preferences (latest wins for conflicts)
src/services/cross-platform-conversation-manager.ts:648:    const mergedPreferences: CustomerPreferences = contexts.reduce((merged, ctx: any) => {
src/services/cross-platform-conversation-manager.ts-649-      if (ctx.preferences && typeof ctx.preferences === 'object') {
src/services/cross-platform-conversation-manager.ts-650-        return { ...merged, ...ctx.preferences };
src/services/cross-platform-conversation-manager.ts-651-      }
--
src/services/cross-platform-conversation-manager.ts-663-    });
src/services/cross-platform-conversation-manager.ts-664-
src/services/cross-platform-conversation-manager.ts-665-    // Extract interests from conversation content
src/services/cross-platform-conversation-manager.ts:666:    const interests = Array.from(new Set(contexts.flatMap((ctx: any) => ctx.interests || [])));
src/services/cross-platform-conversation-manager.ts-667-
src/services/cross-platform-conversation-manager.ts-668-    return {
src/services/cross-platform-conversation-manager.ts-669-      cart: allCartItems,
src/services/cross-platform-conversation-manager.ts-670-      preferences: mergedPreferences,
src/services/cross-platform-conversation-manager.ts-671-      orderHistory: [], // Would be populated from order system
src/services/cross-platform-conversation-manager.ts-672-      interests,
src/services/cross-platform-conversation-manager.ts:673:      budget: contexts.find((ctx: any) => ctx.budget)?.budget || { currency: 'IQD' },
src/services/cross-platform-conversation-manager.ts:674:      urgency: contexts.find((ctx: any) => ctx.urgency)?.urgency || 'medium',
src/services/cross-platform-conversation-manager.ts-675-      language: 'arabic',
src/services/cross-platform-conversation-manager.ts:676:      location: contexts.find((ctx: any) => ctx.location)?.location
src/services/cross-platform-conversation-manager.ts-677-    };
src/services/cross-platform-conversation-manager.ts-678-  }
src/services/cross-platform-conversation-manager.ts-679-
--
src/services/cross-platform-conversation-manager.ts-685-    return 'evening';
src/services/cross-platform-conversation-manager.ts-686-  }
src/services/cross-platform-conversation-manager.ts-687-
src/services/cross-platform-conversation-manager.ts:688:  private async generateCustomerTags(conversations: any[], platformProfiles: PlatformProfile[]): Promise<string[]> {
src/services/cross-platform-conversation-manager.ts-689-    const tags: string[] = [];
src/services/cross-platform-conversation-manager.ts-690-    
src/services/cross-platform-conversation-manager.ts-691-    // Multi-platform user
--
src/services/cross-platform-conversation-manager.ts-734-  private async createOrUpdateTargetConversation(
src/services/cross-platform-conversation-manager.ts-735-    merchantId: string,
src/services/cross-platform-conversation-manager.ts-736-    targetIdentifier: { platform: Platform; id: string },
src/services/cross-platform-conversation-manager.ts:737:    sourceConversation: any
src/services/cross-platform-conversation-manager.ts-738-  ): Promise<any> {
src/services/cross-platform-conversation-manager.ts-739-    const sql: Sql = this.db.getSQL();
src/services/cross-platform-conversation-manager.ts-740-
--
src/services/cross-platform-conversation-manager.ts-770-  }
src/services/cross-platform-conversation-manager.ts-771-
src/services/cross-platform-conversation-manager.ts-772-  private async transferContext(
src/services/cross-platform-conversation-manager.ts:773:    sourceConversation: any,
src/services/cross-platform-conversation-manager.ts:774:    targetConversation: any,
src/services/cross-platform-conversation-manager.ts-775-    fromPlatform: Platform,
src/services/cross-platform-conversation-manager.ts-776-    toPlatform: Platform
src/services/cross-platform-conversation-manager.ts-777-  ): Promise<{ success: boolean; transferredFields: string[] }> {
--
src/services/cross-platform-conversation-manager.ts-832-    }
src/services/cross-platform-conversation-manager.ts-833-  }
src/services/cross-platform-conversation-manager.ts-834-
src/services/cross-platform-conversation-manager.ts:835:  private selectPrimaryConversation(conversations: any[], strategy: string): any {
src/services/cross-platform-conversation-manager.ts-836-    switch (strategy) {
src/services/cross-platform-conversation-manager.ts-837-      case 'latest_wins':
src/services/cross-platform-conversation-manager.ts-838-        return conversations[0]; // Already sorted by updated_at DESC
--
src/services/cross-platform-conversation-manager.ts-845-    }
src/services/cross-platform-conversation-manager.ts-846-  }
src/services/cross-platform-conversation-manager.ts-847-
src/services/cross-platform-conversation-manager.ts:848:  private async mergeConversationContexts(conversations: any[]): Promise<any> {
src/services/cross-platform-conversation-manager.ts:849:    const mergedContext: any = {
src/services/cross-platform-conversation-manager.ts-850-      cart: [],
src/services/cross-platform-conversation-manager.ts-851-      preferences: {},
src/services/cross-platform-conversation-manager.ts-852-      context: {},
--
src/services/cross-platform-conversation-manager.ts-878-
src/services/cross-platform-conversation-manager.ts-879-    // إزالة العناصر المكررة في السلة بناءً على (productId + platform)
src/services/cross-platform-conversation-manager.ts-880-    const seen = new Set<string>();
src/services/cross-platform-conversation-manager.ts:881:    mergedContext.cart = mergedContext.cart.filter((it: any) => {
src/services/cross-platform-conversation-manager.ts-882-      const key = `${it.productId || it.id}-${it.platform || ''}`;
src/services/cross-platform-conversation-manager.ts-883-      if (seen.has(key)) return false;
src/services/cross-platform-conversation-manager.ts-884-      seen.add(key);
--
src/services/cross-platform-conversation-manager.ts-1029-  direction: string;
src/services/cross-platform-conversation-manager.ts-1030-  content: string;
src/services/cross-platform-conversation-manager.ts-1031-  intent?: string;
src/services/cross-platform-conversation-manager.ts:1032:  context: any;
src/services/cross-platform-conversation-manager.ts-1033-}
src/services/cross-platform-conversation-manager.ts-1034-
src/services/cross-platform-conversation-manager.ts-1035-interface ConversionEvent {
--
src/services/cross-platform-conversation-manager.ts-1037-  timestamp: Date;
src/services/cross-platform-conversation-manager.ts-1038-  platform: Platform;
src/services/cross-platform-conversation-manager.ts-1039-  value?: number;
src/services/cross-platform-conversation-manager.ts:1040:  details: any;
src/services/cross-platform-conversation-manager.ts-1041-}
src/services/cross-platform-conversation-manager.ts-1042-
src/services/cross-platform-conversation-manager.ts-1043-interface JourneyInsight {
--
src/repositories/merchant-repository.test.ts-14-
src/repositories/merchant-repository.test.ts-15-describe('MerchantRepository - Production Tests', () => {
src/repositories/merchant-repository.test.ts-16-  let repository: MerchantRepository;
src/repositories/merchant-repository.test.ts:17:  let db: any;
src/repositories/merchant-repository.test.ts:18:  let sql: any;
src/repositories/merchant-repository.test.ts-19-  let testMerchants: string[] = [];
src/repositories/merchant-repository.test.ts-20-
src/repositories/merchant-repository.test.ts-21-  beforeAll(async () => {
--
src/repositories/merchant-repository.test.ts-615-          businessName: `${data.tier} ${data.category} Store`,
src/repositories/merchant-repository.test.ts-616-          businessCategory: data.category,
src/repositories/merchant-repository.test.ts-617-          contactEmail: `${data.tier}.${data.category}@test.com`,
src/repositories/merchant-repository.test.ts:618:          subscriptionTier: data.tier as any
src/repositories/merchant-repository.test.ts-619-        });
src/repositories/merchant-repository.test.ts-620-
src/repositories/merchant-repository.test.ts-621-        testMerchants.push(merchant.id);
--
src/database/migrate.test.ts-15-const BACKUP_SUFFIX = '.test-backup';
src/database/migrate.test.ts-16-
src/database/migrate.test.ts-17-describe('Database Migration System - Production Tests', () => {
src/database/migrate.test.ts:18:  let db: any;
src/database/migrate.test.ts:19:  let sql: any;
src/database/migrate.test.ts-20-  let originalMigrations: string[] = [];
src/database/migrate.test.ts-21-
src/database/migrate.test.ts-22-  beforeAll(async () => {
--
src/database/migrate.test.ts-76-
src/database/migrate.test.ts-77-      expect(tableInfo.length).toBeGreaterThan(0);
src/database/migrate.test.ts-78-      
src/database/migrate.test.ts:79:      const columns = tableInfo.map((col: any) => col.column_name);
src/database/migrate.test.ts-80-      expect(columns).toContain('version');
src/database/migrate.test.ts-81-      expect(columns).toContain('applied_at');
src/database/migrate.test.ts-82-      expect(columns).toContain('execution_time_ms');
--
src/database/migrate.test.ts-411-      `;
src/database/migrate.test.ts-412-
src/database/migrate.test.ts-413-      expect(columns.length).toBe(7);
src/database/migrate.test.ts:414:      expect(columns.find((c: any) => c.column_name === 'metadata').data_type).toBe('jsonb');
src/database/migrate.test.ts-415-
src/database/migrate.test.ts-416-      // Verify constraints
src/database/migrate.test.ts-417-      const constraints = await sql`
--
src/database/migrate.test.ts-420-        WHERE table_name = 'test_complex_table'
src/database/migrate.test.ts-421-      `;
src/database/migrate.test.ts-422-
src/database/migrate.test.ts:423:      expect(constraints.some((c: any) => c.constraint_type === 'CHECK')).toBe(true);
src/database/migrate.test.ts:424:      expect(constraints.some((c: any) => c.constraint_type === 'UNIQUE')).toBe(true);
src/database/migrate.test.ts-425-
src/database/migrate.test.ts-426-      // Verify function exists
src/database/migrate.test.ts-427-      const functions = await sql`
--
src/services/instagram-ai.ts-46-    mediaType?: 'video' | 'carousel' | 'photo';
src/services/instagram-ai.ts-47-    caption?: string;
src/services/instagram-ai.ts-48-    hashtags?: string[];
src/services/instagram-ai.ts:49:    [k: string]: any;
src/services/instagram-ai.ts-50-  };
src/services/instagram-ai.ts-51-  visualPreferences?: {
src/services/instagram-ai.ts-52-    colorScheme: string[];
--
src/services/instagram-ai.ts-93-      `;
src/services/instagram-ai.ts-94-      
src/services/instagram-ai.ts-95-      if (result.length > 0 && result[0].ai_config) {
src/services/instagram-ai.ts:96:        const config = result[0].ai_config as any;
src/services/instagram-ai.ts-97-        return {
src/services/instagram-ai.ts-98-          aiModel: config?.model || 'gpt-4o-mini',
src/services/instagram-ai.ts-99-          maxTokens: config?.maxTokens || 600,
--
src/services/instagram-ai.ts-268-      await this.logInstagramAIInteraction(context, customerMessage, aiResponse);
src/services/instagram-ai.ts-269-
src/services/instagram-ai.ts-270-      return aiResponse;
src/services/instagram-ai.ts:271:    } catch (error: any) {
src/services/instagram-ai.ts-272-      this.logger.error('❌ Instagram AI response generation failed:', {
src/services/instagram-ai.ts-273-        err: error?.message || String(error),
src/services/instagram-ai.ts-274-        stack: error?.stack,
--
src/services/instagram-ai.ts-312-      };
src/services/instagram-ai.ts-313-
src/services/instagram-ai.ts-314-      return aiResponse;
src/services/instagram-ai.ts:315:    } catch (error: any) {
src/services/instagram-ai.ts-316-      this.logger.error('❌ Story reply generation failed:', error?.message || String(error));
src/services/instagram-ai.ts-317-      return this.getInstagramFallbackResponse(context);
src/services/instagram-ai.ts-318-    }
--
src/services/instagram-ai.ts-352-      };
src/services/instagram-ai.ts-353-
src/services/instagram-ai.ts-354-      return aiResponse;
src/services/instagram-ai.ts:355:    } catch (error: any) {
src/services/instagram-ai.ts-356-      this.logger.error('❌ Comment response generation failed:', error?.message || String(error));
src/services/instagram-ai.ts-357-      return this.getInstagramFallbackResponse(context);
src/services/instagram-ai.ts-358-    }
--
src/services/instagram-ai.ts-400-        };
src/services/instagram-ai.ts-401-      }
src/services/instagram-ai.ts-402-      return showcase;
src/services/instagram-ai.ts:403:    } catch (error: any) {
src/services/instagram-ai.ts-404-      this.logger.error('❌ Product showcase generation failed:', error?.message || String(error));
src/services/instagram-ai.ts-405-      return {
src/services/instagram-ai.ts-406-        mediaRecommendations: [],
--
src/services/instagram-ai.ts-453-        };
src/services/instagram-ai.ts-454-      }
src/services/instagram-ai.ts-455-      return analysis;
src/services/instagram-ai.ts:456:    } catch (error: any) {
src/services/instagram-ai.ts-457-      this.logger.error('❌ Content performance analysis failed:', error?.message || String(error));
src/services/instagram-ai.ts-458-      return {
src/services/instagram-ai.ts-459-        viralScore: 0,
--
src/services/instagram-ai.ts-561-   */
src/services/instagram-ai.ts-562-  private buildStoryReplyPrompt(
src/services/instagram-ai.ts-563-    storyReaction: string,
src/services/instagram-ai.ts:564:    storyContext: any,
src/services/instagram-ai.ts-565-    context: InstagramContext
src/services/instagram-ai.ts-566-  ): OpenAI.Chat.Completions.ChatCompletionMessageParam[] {
src/services/instagram-ai.ts-567-    return [
--
src/services/instagram-ai.ts-592-   */
src/services/instagram-ai.ts-593-  private buildCommentReplyPrompt(
src/services/instagram-ai.ts-594-    commentText: string,
src/services/instagram-ai.ts:595:    postContext: any,
src/services/instagram-ai.ts-596-    context: InstagramContext
src/services/instagram-ai.ts-597-  ): OpenAI.Chat.Completions.ChatCompletionMessageParam[] {
src/services/instagram-ai.ts-598-    return [
--
src/services/instagram-ai.ts-622-   * Private: Build product showcase prompt
src/services/instagram-ai.ts-623-   */
src/services/instagram-ai.ts-624-  private buildProductShowcasePrompt(
src/services/instagram-ai.ts:625:    products: any[],
src/services/instagram-ai.ts-626-    context: InstagramContext
src/services/instagram-ai.ts-627-  ): OpenAI.Chat.Completions.ChatCompletionMessageParam[] {
src/services/instagram-ai.ts-628-    const productsText = products.map(p => 
--
src/services/instagram-ai.ts-744-        productBatches.push(batch);
src/services/instagram-ai.ts-745-      }
src/services/instagram-ai.ts-746-      
src/services/instagram-ai.ts:747:      let allProducts: any[] = [];
src/services/instagram-ai.ts-748-      
src/services/instagram-ai.ts-749-      // Process batches concurrently for better performance
src/services/instagram-ai.ts-750-      const batchPromises = productBatches.map(batch => 
--
src/services/telemetry.test.ts-33-describe('📊 Telemetry Service Tests', () => {
src/services/telemetry.test.ts-34-  let telemetryService: TelemetryService;
src/services/telemetry.test.ts-35-  let mockSQL: jest.Mock;
src/services/telemetry.test.ts:36:  let mockLogger: any;
src/services/telemetry.test.ts:37:  let originalPerformance: any;
src/services/telemetry.test.ts-38-
src/services/telemetry.test.ts-39-  beforeEach(() => {
src/services/telemetry.test.ts-40-    jest.clearAllMocks();
--
src/services/telemetry.test.ts-60-    originalPerformance = global.performance;
src/services/telemetry.test.ts-61-    global.performance = {
src/services/telemetry.test.ts-62-      now: jest.fn(() => 1000)
src/services/telemetry.test.ts:63:    } as any;
src/services/telemetry.test.ts-64-
src/services/telemetry.test.ts-65-    telemetryService = new TelemetryService();
src/services/telemetry.test.ts-66-  });
--
src/services/telemetry.test.ts-625-
src/services/telemetry.test.ts-626-    test('✅ should create instance if not exists', () => {
src/services/telemetry.test.ts-627-      // Reset singleton
src/services/telemetry.test.ts:628:      (require('./telemetry.js') as any).telemetryServiceInstance = null;
src/services/telemetry.test.ts-629-
src/services/telemetry.test.ts-630-      const instance = getTelemetryService();
src/services/telemetry.test.ts-631-      expect(instance).toBeInstanceOf(TelemetryService);
--
src/services/telemetry.test.ts-694-    test('✅ should handle circular references in properties', async () => {
src/services/telemetry.test.ts-695-      mockSQL.mockResolvedValue([]);
src/services/telemetry.test.ts-696-
src/services/telemetry.test.ts:697:      const circularObj: any = { name: 'test' };
src/services/telemetry.test.ts-698-      circularObj.self = circularObj;
src/services/telemetry.test.ts-699-
src/services/telemetry.test.ts-700-      const event: TelemetryEvent = {
--
src/services/instagram-hashtag-mention-processor.ts-363-        })),
src/services/instagram-hashtag-mention-processor.ts-364-        mentionAnalytics: {
src/services/instagram-hashtag-mention-processor.ts-365-          totalMentions: mentionStats.reduce((sum, stat) => sum + Number(((stat as unknown) as { mention_type: string; count: string })?.count ?? 0), 0),
src/services/instagram-hashtag-mention-processor.ts:366:          influencerMentions: Number((mentionStats.find(s => ((s as unknown) as { mention_type: string })?.mention_type === 'influencer') as any)?.count ?? 0),
src/services/instagram-hashtag-mention-processor.ts:367:          customerMentions: Number((mentionStats.find(s => ((s as unknown) as { mention_type: string })?.mention_type === 'customer') as any)?.count ?? 0),
src/services/instagram-hashtag-mention-processor.ts:368:          competitorMentions: Number((mentionStats.find(s => ((s as unknown) as { mention_type: string })?.mention_type === 'competitor') as any)?.count ?? 0)
src/services/instagram-hashtag-mention-processor.ts-369-        },
src/services/instagram-hashtag-mention-processor.ts-370-        trendingHashtags,
src/services/instagram-hashtag-mention-processor.ts-371-        recommendedHashtags
--
src/services/instagram-hashtag-mention-processor.ts-775-    return ['منتج', 'جديد', 'عرض']; // Placeholder
src/services/instagram-hashtag-mention-processor.ts-776-  }
src/services/instagram-hashtag-mention-processor.ts-777-
src/services/instagram-hashtag-mention-processor.ts:778:  private generateHashtagStrategy(trend: any): string {
src/services/instagram-hashtag-mention-processor.ts-779-    if (Number(trend.total_usage) > 10) {
src/services/instagram-hashtag-mention-processor.ts-780-      return 'استراتيجية تركيز عالية - استخدم هذا الهاشتاغ في المحتوى الترويجي';
src/services/instagram-hashtag-mention-processor.ts-781-    }
--
src/services/instagram-hashtag-mention-processor.ts-797-    return 'low';
src/services/instagram-hashtag-mention-processor.ts-798-  }
src/services/instagram-hashtag-mention-processor.ts-799-
src/services/instagram-hashtag-mention-processor.ts:800:  private generateMentionResponse(mention: string, type: string, sentiment: string, data: any): string {
src/services/instagram-hashtag-mention-processor.ts-801-    if (type === 'customer' && sentiment === 'positive') {
src/services/instagram-hashtag-mention-processor.ts-802-      return `شكراً @${mention} لك! نقدر تفاعلك معنا 💕`;
src/services/instagram-hashtag-mention-processor.ts-803-    }
--
src/services/instagram-hashtag-mention-processor.ts-871-          hashtag,
src/services/instagram-hashtag-mention-processor.ts-872-          usage_count,
src/services/instagram-hashtag-mention-processor.ts-873-          date
src/services/instagram-hashtag-mention-processor.ts:874:        ) VALUES ${(sql as any).join(values, sql`, `)}
src/services/instagram-hashtag-mention-processor.ts-875-        ON CONFLICT (merchant_id, hashtag, date)
src/services/instagram-hashtag-mention-processor.ts-876-        DO UPDATE SET
src/services/instagram-hashtag-mention-processor.ts-877-          usage_count = hashtag_trends.usage_count + EXCLUDED.usage_count,
--
src/services/conversation-ai-orchestrator.ts-181-        adaptations
src/services/conversation-ai-orchestrator.ts-182-      };
src/services/conversation-ai-orchestrator.ts-183-
src/services/conversation-ai-orchestrator.ts:184:    } catch (error: any) {
src/services/conversation-ai-orchestrator.ts-185-      this.aiService?.['logger']?.error?.(`❌ Platform response generation failed for ${platform}`, {
src/services/conversation-ai-orchestrator.ts-186-        err: error?.message || String(error)
src/services/conversation-ai-orchestrator.ts-187-      });
--
src/services/conversation-ai-orchestrator.ts-242-        contextPreserved: true
src/services/conversation-ai-orchestrator.ts-243-      };
src/services/conversation-ai-orchestrator.ts-244-
src/services/conversation-ai-orchestrator.ts:245:    } catch (error: any) {
src/services/conversation-ai-orchestrator.ts-246-      this.aiService['logger']?.error('❌ Cross-platform adaptation failed', error);
src/services/conversation-ai-orchestrator.ts-247-      return {
src/services/conversation-ai-orchestrator.ts-248-        adaptedMessage: originalMessage,
--
src/services/conversation-ai-orchestrator.ts-265-    recommendations: string[];
src/services/conversation-ai-orchestrator.ts-266-  }> {
src/services/conversation-ai-orchestrator.ts-267-    try {
src/services/conversation-ai-orchestrator.ts:268:      const sql = this.db.getSQL() as any;
src/services/conversation-ai-orchestrator.ts-269-
src/services/conversation-ai-orchestrator.ts-270-      // Get customer interactions across platforms
src/services/conversation-ai-orchestrator.ts-271-      const interactions = await sql<InteractionRow[]>`
--
src/services/conversation-ai-orchestrator.ts-302-        recommendations
src/services/conversation-ai-orchestrator.ts-303-      };
src/services/conversation-ai-orchestrator.ts-304-
src/services/conversation-ai-orchestrator.ts:305:    } catch (error: any) {
src/services/conversation-ai-orchestrator.ts-306-      console.error('❌ Conversation insights generation failed:', error?.message || String(error));
src/services/conversation-ai-orchestrator.ts-307-      return {
src/services/conversation-ai-orchestrator.ts-308-        customerProfile: {} as EnhancedCustomerProfile,
--
src/services/conversation-ai-orchestrator.ts-321-    merchantId: string
src/services/conversation-ai-orchestrator.ts-322-  ): Promise<CrossPlatformContext> {
src/services/conversation-ai-orchestrator.ts-323-    try {
src/services/conversation-ai-orchestrator.ts:324:      const sql = this.db.getSQL() as any;
src/services/conversation-ai-orchestrator.ts-325-
src/services/conversation-ai-orchestrator.ts-326-      const platformHistory = await sql<PlatformHistoryRow[]>`
src/services/conversation-ai-orchestrator.ts-327-        SELECT 
--
src/services/conversation-ai-orchestrator.ts-384-        totalInteractions
src/services/conversation-ai-orchestrator.ts-385-      };
src/services/conversation-ai-orchestrator.ts-386-
src/services/conversation-ai-orchestrator.ts:387:    } catch (error: any) {
src/services/conversation-ai-orchestrator.ts-388-      console.error('❌ Error getting cross-platform context:', error?.message || String(error));
src/services/conversation-ai-orchestrator.ts-389-      return {
src/services/conversation-ai-orchestrator.ts-390-        hasWhatsAppHistory: false,
--
src/services/conversation-ai-orchestrator.ts-631-    return 'evening';
src/services/conversation-ai-orchestrator.ts-632-  }
src/services/conversation-ai-orchestrator.ts-633-
src/services/conversation-ai-orchestrator.ts:634:  private analyzeResponsePatterns(interactions: InteractionRow[]): any {
src/services/conversation-ai-orchestrator.ts-635-    // Implementation for response pattern analysis
src/services/conversation-ai-orchestrator.ts-636-    return {};
src/services/conversation-ai-orchestrator.ts-637-  }
--
src/services/conversation-ai-orchestrator.ts-670-    adaptations: PlatformAdaptation[]
src/services/conversation-ai-orchestrator.ts-671-  ): Promise<void> {
src/services/conversation-ai-orchestrator.ts-672-    try {
src/services/conversation-ai-orchestrator.ts:673:      const sql = this.db.getSQL() as any;
src/services/conversation-ai-orchestrator.ts-674-      // قص التفاصيل الطويلة لتفادي قيود الأعمدة/الفهارس
src/services/conversation-ai-orchestrator.ts-675-      const safeDetails = {
src/services/conversation-ai-orchestrator.ts-676-        platform,
--
src/services/conversation-ai-orchestrator.ts-698-          true
src/services/conversation-ai-orchestrator.ts-699-        )
src/services/conversation-ai-orchestrator.ts-700-      `;
src/services/conversation-ai-orchestrator.ts:701:    } catch (error: any) {
src/services/conversation-ai-orchestrator.ts-702-      console.error('❌ Platform interaction logging failed:', error?.message || String(error));
src/services/conversation-ai-orchestrator.ts-703-    }
src/services/conversation-ai-orchestrator.ts-704-  }
--
src/services/conversation-ai-orchestrator.ts-721-            message: baseMsg,
src/services/conversation-ai-orchestrator.ts-722-            messageAr: baseMsg,
src/services/conversation-ai-orchestrator.ts-723-            intent: 'SUPPORT',
src/services/conversation-ai-orchestrator.ts:724:            stage: (context as any).stage,
src/services/conversation-ai-orchestrator.ts-725-            actions: [{ type: 'ESCALATE', data: { reason: 'AI_ERROR' }, priority: 1 }],
src/services/conversation-ai-orchestrator.ts-726-            products: [],
src/services/conversation-ai-orchestrator.ts-727-            confidence: 0.1,
--
src/services/conversation-ai-orchestrator.ts-731-            engagement: { likelyToShare: false, viralPotential: 0, userGeneratedContent: false }
src/services/conversation-ai-orchestrator.ts-732-          } as InstagramAIResponse)
src/services/conversation-ai-orchestrator.ts-733-        : ({
src/services/conversation-ai-orchestrator.ts:734:            message: baseMsg, messageAr: baseMsg, intent: 'SUPPORT', stage: (context as any).stage,
src/services/conversation-ai-orchestrator.ts-735-            actions: [{ type: 'ESCALATE', data: { reason: 'AI_ERROR' }, priority: 1 }],
src/services/conversation-ai-orchestrator.ts-736-            products: [], confidence: 0.1, tokens: { prompt: 0, completion: 0, total: 0 }, responseTime: 0
src/services/conversation-ai-orchestrator.ts-737-          } as AIResponse);
--
src/services/conversation-ai-orchestrator.ts-750-  whatsappInteractions: number;
src/services/conversation-ai-orchestrator.ts-751-  instagramInteractions: number;
src/services/conversation-ai-orchestrator.ts-752-  preferredTimeOfDay: string;
src/services/conversation-ai-orchestrator.ts:753:  responsePatterns: any;
src/services/conversation-ai-orchestrator.ts-754-  purchaseIntent: number;
src/services/conversation-ai-orchestrator.ts-755-}
src/services/conversation-ai-orchestrator.ts-756-
--
src/repositories/index.ts-168-   * Get combined statistics from all repositories
src/repositories/index.ts-169-   */
src/repositories/index.ts-170-  public async getCombinedStats(merchantId?: string): Promise<{
src/repositories/index.ts:171:    merchants: any;
src/repositories/index.ts:172:    conversations: any;
src/repositories/index.ts:173:    messages: any;
src/repositories/index.ts:174:    credentials: any;
src/repositories/index.ts-175-    timestamp: Date;
src/repositories/index.ts-176-  }> {
src/repositories/index.ts-177-    const [merchantStats, conversationStats, messageStats] = await Promise.all([
--
src/services/instagram-ai.test.ts-106-    });
src/services/instagram-ai.test.ts-107-
src/services/instagram-ai.test.ts-108-    // Mock OpenAI constructor and methods
src/services/instagram-ai.test.ts:109:    (OpenAI as jest.MockedClass<typeof OpenAI>).mockImplementation(() => mockOpenAI as any);
src/services/instagram-ai.test.ts-110-
src/services/instagram-ai.test.ts-111-    instagramAIService = new InstagramAIService();
src/services/instagram-ai.test.ts-112-  });
--
src/services/instagram-ai.test.ts-655-
src/services/instagram-ai.test.ts-656-  describe('Hashtag Generation', () => {
src/services/instagram-ai.test.ts-657-    test('✅ should generate relevant hashtags', async () => {
src/services/instagram-ai.test.ts:658:      const hashtags = await (instagramAIService as any).generateRelevantHashtags(
src/services/instagram-ai.test.ts-659-        'أريد فستان للزفاف',
src/services/instagram-ai.test.ts-660-        sampleInstagramContext
src/services/instagram-ai.test.ts-661-      );
--
src/services/instagram-ai.test.ts-675-        }
src/services/instagram-ai.test.ts-676-      };
src/services/instagram-ai.test.ts-677-
src/services/instagram-ai.test.ts:678:      const hashtags = await (instagramAIService as any).generateRelevantHashtags(
src/services/instagram-ai.test.ts-679-        'أريد جوال جديد',
src/services/instagram-ai.test.ts-680-        electronicsContext
src/services/instagram-ai.test.ts-681-      );
--
src/services/instagram-ai.test.ts-686-
src/services/instagram-ai.test.ts-687-    test('❌ should return fallback hashtags on error', async () => {
src/services/instagram-ai.test.ts-688-      // Force error by passing invalid context
src/services/instagram-ai.test.ts:689:      const hashtags = await (instagramAIService as any).generateRelevantHashtags(
src/services/instagram-ai.test.ts-690-        'test',
src/services/instagram-ai.test.ts-691-        null
src/services/instagram-ai.test.ts-692-      );
--
src/services/instagram-ai.test.ts-697-
src/services/instagram-ai.test.ts-698-  describe('Contextual Fallbacks', () => {
src/services/instagram-ai.test.ts-699-    test('✅ should provide different fallbacks by interaction type', () => {
src/services/instagram-ai.test.ts:700:      const storyReplyFallback = (instagramAIService as any).getContextualFallback(
src/services/instagram-ai.test.ts-701-        { ...sampleInstagramContext, interactionType: 'story_reply' },
src/services/instagram-ai.test.ts-702-        'AI_API_ERROR'
src/services/instagram-ai.test.ts-703-      );
src/services/instagram-ai.test.ts-704-
src/services/instagram-ai.test.ts:705:      const dmFallback = (instagramAIService as any).getContextualFallback(
src/services/instagram-ai.test.ts-706-        { ...sampleInstagramContext, interactionType: 'dm' },
src/services/instagram-ai.test.ts-707-        'AI_API_ERROR'
src/services/instagram-ai.test.ts-708-      );
--
src/services/instagram-ai.test.ts-712-    });
src/services/instagram-ai.test.ts-713-
src/services/instagram-ai.test.ts-714-    test('✅ should handle different error types', () => {
src/services/instagram-ai.test.ts:715:      const rateLimitFallback = (instagramAIService as any).getContextualFallback(
src/services/instagram-ai.test.ts-716-        sampleInstagramContext,
src/services/instagram-ai.test.ts-717-        'RATE_LIMIT'
src/services/instagram-ai.test.ts-718-      );
src/services/instagram-ai.test.ts-719-
src/services/instagram-ai.test.ts:720:      const networkErrorFallback = (instagramAIService as any).getContextualFallback(
src/services/instagram-ai.test.ts-721-        sampleInstagramContext,
src/services/instagram-ai.test.ts-722-        'NETWORK_ERROR'
src/services/instagram-ai.test.ts-723-      );
--
src/services/instagram-ai.test.ts-727-    });
src/services/instagram-ai.test.ts-728-
src/services/instagram-ai.test.ts-729-    test('✅ should set appropriate engagement values for fallbacks', () => {
src/services/instagram-ai.test.ts:730:      const storyFallback = (instagramAIService as any).getContextualFallback(
src/services/instagram-ai.test.ts-731-        { ...sampleInstagramContext, interactionType: 'story_reply' },
src/services/instagram-ai.test.ts-732-        'AI_API_ERROR'
src/services/instagram-ai.test.ts-733-      );
src/services/instagram-ai.test.ts-734-
src/services/instagram-ai.test.ts:735:      const dmFallback = (instagramAIService as any).getContextualFallback(
src/services/instagram-ai.test.ts-736-        { ...sampleInstagramContext, interactionType: 'dm' },
src/services/instagram-ai.test.ts-737-        'AI_API_ERROR'
src/services/instagram-ai.test.ts-738-      );
--
src/services/instagram-ai.test.ts-822-        () => Promise.resolve('result3')
src/services/instagram-ai.test.ts-823-      ];
src/services/instagram-ai.test.ts-824-
src/services/instagram-ai.test.ts:825:      const results = await (instagramAIService as any).processCommentBatch(operations);
src/services/instagram-ai.test.ts-826-
src/services/instagram-ai.test.ts-827-      expect(results).toEqual(['result1', 'result2', 'result3']);
src/services/instagram-ai.test.ts-828-    });
--
src/services/instagram-ai.test.ts-834-        () => Promise.resolve('success2')
src/services/instagram-ai.test.ts-835-      ];
src/services/instagram-ai.test.ts-836-
src/services/instagram-ai.test.ts:837:      const results = await (instagramAIService as any).processCommentBatch(operations);
src/services/instagram-ai.test.ts-838-
src/services/instagram-ai.test.ts-839-      expect(results).toEqual([]);
src/services/instagram-ai.test.ts-840-    });
--
src/services/instagram-ai.test.ts-851-      mockSQL.mockResolvedValue(manyProducts.slice(0, 50)); // Simulate batch response
src/services/instagram-ai.test.ts-852-
src/services/instagram-ai.test.ts-853-      const productIds = manyProducts.map(p => p.id);
src/services/instagram-ai.test.ts:854:      const results = await (instagramAIService as any).getProductsForShowcase(
src/services/instagram-ai.test.ts-855-        productIds,
src/services/instagram-ai.test.ts-856-        'merchant-123'
src/services/instagram-ai.test.ts-857-      );
--
src/services/instagram-ai.test.ts-872-
src/services/instagram-ai.test.ts-873-    test('✅ should create instance if not exists', () => {
src/services/instagram-ai.test.ts-874-      // Reset singleton
src/services/instagram-ai.test.ts:875:      (require('./instagram-ai.js') as any).instagramAIServiceInstance = null;
src/services/instagram-ai.test.ts-876-
src/services/instagram-ai.test.ts-877-      const instance = getInstagramAIService();
src/services/instagram-ai.test.ts-878-      expect(instance).toBeInstanceOf(InstagramAIService);
--
src/services/instagram-ai.test.ts-883-    test('✅ should handle unknown interaction type', () => {
src/services/instagram-ai.test.ts-884-      const unknownContext = {
src/services/instagram-ai.test.ts-885-        ...sampleInstagramContext,
src/services/instagram-ai.test.ts:886:        interactionType: 'unknown_type' as any
src/services/instagram-ai.test.ts-887-      };
src/services/instagram-ai.test.ts-888-
src/services/instagram-ai.test.ts:889:      const fallback = (instagramAIService as any).getContextualFallback(
src/services/instagram-ai.test.ts-890-        unknownContext,
src/services/instagram-ai.test.ts-891-        'AI_API_ERROR'
src/services/instagram-ai.test.ts-892-      );
--
src/services/service-controller.ts-82-    const { getLogger } = await import('./logger.js');
src/services/service-controller.ts-83-    
src/services/service-controller.ts-84-    this.db = getDatabase();
src/services/service-controller.ts:85:    this.pool = (this.db as any).poolInstance;
src/services/service-controller.ts-86-    this.logger = getLogger({ component: 'service-controller' });
src/services/service-controller.ts-87-  }
src/services/service-controller.ts-88-
--
src/services/service-controller.ts-197-
src/services/service-controller.ts-198-      const services: Record<string, ServiceStatus> = {};
src/services/service-controller.ts-199-      
src/services/service-controller.ts:200:      result.forEach((row: any) => {
src/services/service-controller.ts-201-        services[row.service_name] = {
src/services/service-controller.ts-202-          enabled: row.enabled,
src/services/service-controller.ts-203-          lastToggled: row.last_toggled,
--
src/services/service-controller.ts-288-      for (const service of instagramServices) {
src/services/service-controller.ts-289-        await this.toggleService({
src/services/service-controller.ts-290-          merchantId,
src/services/service-controller.ts:291:          service: service as any,
src/services/service-controller.ts-292-          enabled: true,
src/services/service-controller.ts-293-          toggledBy,
src/services/service-controller.ts-294-          reason: 'Instagram setup completion'
--
src/services/service-controller.ts-324-      for (const service of allServices) {
src/services/service-controller.ts-325-        await this.toggleService({
src/services/service-controller.ts-326-          merchantId,
src/services/service-controller.ts:327:          service: service as any,
src/services/service-controller.ts-328-          enabled: false,
src/services/service-controller.ts-329-          toggledBy,
src/services/service-controller.ts-330-          reason
--
src/services/service-controller.ts-360-        WHERE mss.merchant_id = ${merchantId}::uuid
src/services/service-controller.ts-361-      `;
src/services/service-controller.ts-362-
src/services/service-controller.ts:363:      return healthData.map((row: any) => {
src/services/service-controller.ts-364-        const uptime = Date.now() - new Date(row.last_toggled).getTime();
src/services/service-controller.ts-365-        let status: ServiceHealth['status'] = 'healthy';
src/services/service-controller.ts-366-
--
src/services/service-controller.ts-395-    merchantId: string,
src/services/service-controller.ts-396-    service: string,
src/services/service-controller.ts-397-    error: Error,
src/services/service-controller.ts:398:    context?: any
src/services/service-controller.ts-399-  ): Promise<void> {
src/services/service-controller.ts-400-    try {
src/services/service-controller.ts-401-      await this.sql`
--
src/services/service-controller.ts-424-      if (errorCount > 50) {
src/services/service-controller.ts-425-        await this.toggleService({
src/services/service-controller.ts-426-          merchantId,
src/services/service-controller.ts:427:          service: service as any,
src/services/service-controller.ts-428-          enabled: false,
src/services/service-controller.ts-429-          reason: `Auto-disabled: ${errorCount} errors in last hour`,
src/services/service-controller.ts-430-          toggledBy: 'system'
--
src/services/instagram-comments-manager.ts-554-        },
src/services/instagram-comments-manager.ts-555-        salesInquiries: Number(stats?.sales_inquiries) || 0,
src/services/instagram-comments-manager.ts-556-        dmConversions: 0, // Would need additional tracking
src/services/instagram-comments-manager.ts:557:        topCommentingUsers: topUsers.map((user: any) => ({
src/services/instagram-comments-manager.ts-558-          username: ((user as unknown) as { username: string; comment_count: string; engagement_score: string })?.username ?? '',
src/services/instagram-comments-manager.ts-559-          commentCount: Number(((user as unknown) as { username: string; comment_count: string; engagement_score: string })?.comment_count ?? 0),
src/services/instagram-comments-manager.ts-560-          engagementScore: Number(((user as unknown) as { username: string; comment_count: string; engagement_score: string })?.engagement_score ?? 0)
--
src/services/instagram-comments-manager.ts-715-  /**
src/services/instagram-comments-manager.ts-716-   * Private: Check if should invite to DM
src/services/instagram-comments-manager.ts-717-   */
src/services/instagram-comments-manager.ts:718:  private shouldInviteToDM(comment: CommentInteraction, analysis: any): boolean {
src/services/instagram-comments-manager.ts-719-    // Invite to DM for detailed sales inquiries
src/services/instagram-comments-manager.ts-720-    const detailedInquiryKeywords = [
src/services/instagram-comments-manager.ts-721-      'سعر', 'أسعار', 'كم', 'توصيل', 'طلب', 'اشتري',
--
src/services/instagram-comments-manager.ts-784-   */
src/services/instagram-comments-manager.ts-785-  private async storeCommentAnalysis(
src/services/instagram-comments-manager.ts-786-    commentId: string,
src/services/instagram-comments-manager.ts:787:    analysis: any,
src/services/instagram-comments-manager.ts-788-    merchantId: string
src/services/instagram-comments-manager.ts-789-  ): Promise<void> {
src/services/instagram-comments-manager.ts-790-    try {
--
src/services/logger.ts-17-  merchantId?: string;
src/services/logger.ts-18-  userId?: string;
src/services/logger.ts-19-  sessionId?: string;
src/services/logger.ts:20:  [key: string]: any;
src/services/logger.ts-21-}
src/services/logger.ts-22-
src/services/logger.ts-23-export interface LogEntry {
--
src/services/logger.ts-109-   */
src/services/logger.ts-110-  error(message: string, err?: Error | any, context?: LogContext): void;
src/services/logger.ts-111-  error(context: LogContext, message: string): void;
src/services/logger.ts:112:  error(arg1: string | LogContext, arg2?: any, arg3?: LogContext): void {
src/services/logger.ts-113-    if (typeof arg1 === 'string') {
src/services/logger.ts-114-      const message = arg1;
src/services/logger.ts-115-      const err = arg2;
--
src/services/logger.ts-127-   */
src/services/logger.ts-128-  fatal(message: string, err?: Error | any, context?: LogContext): void;
src/services/logger.ts-129-  fatal(context: LogContext, message: string): void;
src/services/logger.ts:130:  fatal(arg1: string | LogContext, arg2?: any, arg3?: LogContext): void {
src/services/logger.ts-131-    if (typeof arg1 === 'string') {
src/services/logger.ts-132-      const message = arg1;
src/services/logger.ts-133-      const err = arg2;
--
src/services/logger.ts-143-  /**
src/services/logger.ts-144-   * Core logging method with top-level context and error
src/services/logger.ts-145-   */
src/services/logger.ts:146:  private log(level: LogLevel, message: string, context?: LogContext & { err?: any; error?: any }): void {
src/services/logger.ts-147-    if (!this.shouldLog(level)) return;
src/services/logger.ts-148-
src/services/logger.ts:149:    const ctx = this.redactSensitiveData({ ...this.context, ...(context || {}) }) as LogContext & { err?: any; error?: any };
src/services/logger.ts:150:    const { err, error, ...safeCtx } = ctx as any;
src/services/logger.ts-151-    const finalError = err ?? error;
src/services/logger.ts-152-
src/services/logger.ts-153-    const entry: LogEntry = {
--
src/services/logger.ts-166-    
src/services/logger.ts-167-    // Remove timestamp from production output since Render adds its own
src/services/logger.ts-168-    if (config.environment === 'production') {
src/services/logger.ts:169:      delete (entry as any).timestamp;
src/services/logger.ts-170-    }
src/services/logger.ts-171-
src/services/logger.ts-172-    const out = (level === 'error' || level === 'fatal') ? process.stderr : process.stdout;
--
src/services/logger.ts-205-  /**
src/services/logger.ts-206-   * Redact sensitive information from logs
src/services/logger.ts-207-   */
src/services/logger.ts:208:  private redactSensitiveData(data: any): any {
src/services/logger.ts-209-    if (!data || typeof data !== 'object') return data;
src/services/logger.ts-210-
src/services/logger.ts-211-    const redacted = { ...data };
--
src/tests/utility-messages.test.ts-45-
src/tests/utility-messages.test.ts-46-mock.module('../database/connection.js', () => ({
src/tests/utility-messages.test.ts-47-  getDatabase: () => ({
src/tests/utility-messages.test.ts:48:    getSQL: () => async (strings: TemplateStringsArray, ...params: any[]) => {
src/tests/utility-messages.test.ts-49-      const [templateId, merchantId] = params;
src/tests/utility-messages.test.ts-50-      if (templateId === 'tpl1' && merchantId === 'merchant1') {
src/tests/utility-messages.test.ts-51-        return [
--
src/services/instagram-testing-orchestrator.ts-193-  public async runScenario(
src/services/instagram-testing-orchestrator.ts-194-    scenarioId: string,
src/services/instagram-testing-orchestrator.ts-195-    merchantId: string,
src/services/instagram-testing-orchestrator.ts:196:    context?: any
src/services/instagram-testing-orchestrator.ts-197-  ): Promise<TestResult> {
src/services/instagram-testing-orchestrator.ts-198-    try {
src/services/instagram-testing-orchestrator.ts-199-      const scenario = this.findScenario(scenarioId);
--
src/services/instagram-testing-orchestrator.ts-286-
src/services/instagram-testing-orchestrator.ts-287-      const startTime = Date.now();
src/services/instagram-testing-orchestrator.ts-288-      const endTime = startTime + (options.duration * 1000);
src/services/instagram-testing-orchestrator.ts:289:      const results: any[] = [];
src/services/instagram-testing-orchestrator.ts-290-      const promises: Promise<any>[] = [];
src/services/instagram-testing-orchestrator.ts-291-
src/services/instagram-testing-orchestrator.ts-292-      // Create concurrent user simulations
--
src/services/instagram-testing-orchestrator.ts-714-    step: TestStep,
src/services/instagram-testing-orchestrator.ts-715-    scenario: TestScenario,
src/services/instagram-testing-orchestrator.ts-716-    merchantId: string,
src/services/instagram-testing-orchestrator.ts:717:    context?: any
src/services/instagram-testing-orchestrator.ts:718:  ): Promise<{ success: boolean; output?: any; error?: string }> {
src/services/instagram-testing-orchestrator.ts-719-    try {
src/services/instagram-testing-orchestrator.ts:720:      let result: any;
src/services/instagram-testing-orchestrator.ts-721-      const timeout = step.timeout || 10000;
src/services/instagram-testing-orchestrator.ts-722-
src/services/instagram-testing-orchestrator.ts-723-      const executeAction = async () => {
--
src/services/instagram-testing-orchestrator.ts-821-  /**
src/services/instagram-testing-orchestrator.ts-822-   * Private: Validate step result
src/services/instagram-testing-orchestrator.ts-823-   */
src/services/instagram-testing-orchestrator.ts:824:  private validateStepResult(result: any, validations: string[]): boolean {
src/services/instagram-testing-orchestrator.ts-825-    for (const validation of validations) {
src/services/instagram-testing-orchestrator.ts-826-      switch (validation) {
src/services/instagram-testing-orchestrator.ts-827-        case 'story_reply_created':
--
src/services/instagram-testing-orchestrator.ts-856-  private async executeSuite(
src/services/instagram-testing-orchestrator.ts-857-    suite: TestSuite,
src/services/instagram-testing-orchestrator.ts-858-    merchantId: string,
src/services/instagram-testing-orchestrator.ts:859:    options: any
src/services/instagram-testing-orchestrator.ts-860-  ): Promise<TestExecutionReport> {
src/services/instagram-testing-orchestrator.ts-861-    const startTime = Date.now();
src/services/instagram-testing-orchestrator.ts-862-    
--
src/services/instagram-testing-orchestrator.ts-979-  /**
src/services/instagram-testing-orchestrator.ts-980-   * Private: Should run suite based on options
src/services/instagram-testing-orchestrator.ts-981-   */
src/services/instagram-testing-orchestrator.ts:982:  private shouldRunSuite(suite: TestSuite, options: any): boolean {
src/services/instagram-testing-orchestrator.ts-983-    if (options.categories && options.categories.length > 0) {
src/services/instagram-testing-orchestrator.ts-984-      const suiteCategories = suite.scenarios.map(s => s.category);
src/services/instagram-testing-orchestrator.ts-985-      const hasMatchingCategory = options.categories.some((cat: string) => 
src/services/instagram-testing-orchestrator.ts:986:        suiteCategories.includes(cat as any)
src/services/instagram-testing-orchestrator.ts-987-      );
src/services/instagram-testing-orchestrator.ts-988-      if (!hasMatchingCategory) return false;
src/services/instagram-testing-orchestrator.ts-989-    }
--
src/services/instagram-testing-orchestrator.ts-1006-   * Private: Test API endpoints
src/services/instagram-testing-orchestrator.ts-1007-   */
src/services/instagram-testing-orchestrator.ts-1008-  private async testAPIEndpoints(
src/services/instagram-testing-orchestrator.ts:1009:    instagramClient: any,
src/services/instagram-testing-orchestrator.ts-1010-    credentials: InstagramAPICredentials,
src/services/instagram-testing-orchestrator.ts-1011-    merchantId: string
src/services/instagram-testing-orchestrator.ts-1012-  ): Promise<Array<{
--
src/services/instagram-testing-orchestrator.ts-1086-  /**
src/services/instagram-testing-orchestrator.ts-1087-   * Private: Check rate limits
src/services/instagram-testing-orchestrator.ts-1088-   */
src/services/instagram-testing-orchestrator.ts:1089:  private async checkRateLimits(instagramClient: any): Promise<{
src/services/instagram-testing-orchestrator.ts-1090-    remaining: number;
src/services/instagram-testing-orchestrator.ts-1091-    resetTime: Date;
src/services/instagram-testing-orchestrator.ts-1092-    status: 'ok' | 'warning' | 'critical';
--
src/services/instagram-testing-orchestrator.ts-1119-   */
src/services/instagram-testing-orchestrator.ts-1120-  private generateAPIRecommendations(
src/services/instagram-testing-orchestrator.ts-1121-    health: string,
src/services/instagram-testing-orchestrator.ts:1122:    endpointTests: any[],
src/services/instagram-testing-orchestrator.ts:1123:    webhookValidation: any,
src/services/instagram-testing-orchestrator.ts:1124:    rateLimitStatus: any
src/services/instagram-testing-orchestrator.ts-1125-  ): string[] {
src/services/instagram-testing-orchestrator.ts-1126-    const recommendations: string[] = [];
src/services/instagram-testing-orchestrator.ts-1127-
--
src/services/instagram-testing-orchestrator.ts-1153-    scenarios: string[],
src/services/instagram-testing-orchestrator.ts-1154-    endTime: number
src/services/instagram-testing-orchestrator.ts-1155-  ): Promise<any[]> {
src/services/instagram-testing-orchestrator.ts:1156:    const results: any[] = [];
src/services/instagram-testing-orchestrator.ts-1157-
src/services/instagram-testing-orchestrator.ts-1158-    while (Date.now() < endTime) {
src/services/instagram-testing-orchestrator.ts-1159-      for (const scenarioId of scenarios) {
--
src/services/instagram-testing-orchestrator.ts-1187-  /**
src/services/instagram-testing-orchestrator.ts-1188-   * Private: Generate performance recommendations
src/services/instagram-testing-orchestrator.ts-1189-   */
src/services/instagram-testing-orchestrator.ts:1190:  private generatePerformanceRecommendations(results: any[]): string[] {
src/services/instagram-testing-orchestrator.ts-1191-    const recommendations: string[] = [];
src/services/instagram-testing-orchestrator.ts-1192-
src/services/instagram-testing-orchestrator.ts-1193-    const averageResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
--
src/services/instagram-testing-orchestrator.ts-1210-  /**
src/services/instagram-testing-orchestrator.ts-1211-   * Private: Store performance test result
src/services/instagram-testing-orchestrator.ts-1212-   */
src/services/instagram-testing-orchestrator.ts:1213:  private async storePerformanceTestResult(report: any, merchantId: string): Promise<void> {
src/services/instagram-testing-orchestrator.ts-1214-    try {
src/services/instagram-testing-orchestrator.ts-1215-      const sql = this.db.getSQL();
src/services/instagram-testing-orchestrator.ts-1216-
--
src/services/instagram-testing-orchestrator.ts-1249-  /**
src/services/instagram-testing-orchestrator.ts-1250-   * Private: Store validation result
src/services/instagram-testing-orchestrator.ts-1251-   */
src/services/instagram-testing-orchestrator.ts:1252:  private async storeValidationResult(result: any, merchantId: string): Promise<void> {
src/services/instagram-testing-orchestrator.ts-1253-    try {
src/services/instagram-testing-orchestrator.ts-1254-      const sql = this.db.getSQL();
src/services/instagram-testing-orchestrator.ts-1255-
--
src/services/RedisSimpleHealthCheck.ts-72-      success: true,
src/services/RedisSimpleHealthCheck.ts-73-      latency
src/services/RedisSimpleHealthCheck.ts-74-    };
src/services/RedisSimpleHealthCheck.ts:75:  } catch (error: any) {
src/services/RedisSimpleHealthCheck.ts-76-    return {
src/services/RedisSimpleHealthCheck.ts-77-      success: false,
src/services/RedisSimpleHealthCheck.ts-78-      error: error.message
--
src/services/instagram-webhook.ts-504-        timestamp: timestamp,
src/services/instagram-webhook.ts-505-        isReply: false, // Top-level comment
src/services/instagram-webhook.ts-506-        metadata: {
src/services/instagram-webhook.ts:507:          postType: event.value.media.media_product_type as any,
src/services/instagram-webhook.ts-508-          isInfluencerComment: false, // Could be enhanced with user analysis
src/services/instagram-webhook.ts-509-          hasHashtags: commentText.includes('#'),
src/services/instagram-webhook.ts-510-          mentionsCount: (commentText.match(/@\w+/g) || []).length
--
src/services/instagram-webhook.ts-782-      `;
src/services/instagram-webhook.ts-783-
src/services/instagram-webhook.ts-784-      // Build Instagram context
src/services/instagram-webhook.ts:785:      let session: any = {};
src/services/instagram-webhook.ts-786-      try {
src/services/instagram-webhook.ts-787-        session = typeof conversation.session_data === 'string'
src/services/instagram-webhook.ts-788-          ? JSON.parse(conversation.session_data)
--
src/services/instagram-webhook.ts-1184-   * Private: Process media attachment with Media Manager
src/services/instagram-webhook.ts-1185-   */
src/services/instagram-webhook.ts-1186-  private async processMediaAttachment(
src/services/instagram-webhook.ts:1187:    attachment: any,
src/services/instagram-webhook.ts-1188-    conversationId: string,
src/services/instagram-webhook.ts-1189-    merchantId: string,
src/services/instagram-webhook.ts-1190-    userId: string,
--
src/services/instagram-webhook.ts-1246-   * Private: Map Instagram media type to our media type
src/services/instagram-webhook.ts-1247-   */
src/services/instagram-webhook.ts-1248-  private mapInstagramMediaType(instagramType: string): 'image' | 'video' | 'audio' | 'document' | 'sticker' | 'gif' {
src/services/instagram-webhook.ts:1249:    const typeMapping: { [key: string]: any } = {
src/services/instagram-webhook.ts-1250-      'image': 'image',
src/services/instagram-webhook.ts-1251-      'photo': 'image',
src/services/instagram-webhook.ts-1252-      'video': 'video',
--
src/services/instagram-webhook.ts-1277-   * Private: Legacy media attachment processing (fallback)
src/services/instagram-webhook.ts-1278-   */
src/services/instagram-webhook.ts-1279-  private async legacyProcessMediaAttachment(
src/services/instagram-webhook.ts:1280:    attachment: any,
src/services/instagram-webhook.ts-1281-    conversationId: string,
src/services/instagram-webhook.ts-1282-    textContent: string
src/services/instagram-webhook.ts-1283-  ): Promise<void> {
--
src/services/logger.test.ts-20-
src/services/logger.test.ts-21-describe('📝 Logger Service Tests', () => {
src/services/logger.test.ts-22-  let logger: Logger;
src/services/logger.test.ts:23:  let originalStdout: any;
src/services/logger.test.ts:24:  let originalStderr: any;
src/services/logger.test.ts:25:  let originalEnv: any;
src/services/logger.test.ts-26-  let capturedOutput: string[];
src/services/logger.test.ts-27-  let capturedErrors: string[];
src/services/logger.test.ts-28-
--
src/services/logger.test.ts-495-
src/services/logger.test.ts-496-  describe('Edge Cases', () => {
src/services/logger.test.ts-497-    test('✅ should handle null/undefined messages', () => {
src/services/logger.test.ts:498:      logger.info(null as any);
src/services/logger.test.ts:499:      logger.info(undefined as any);
src/services/logger.test.ts-500-      
src/services/logger.test.ts-501-      expect(capturedOutput.length).toBe(2);
src/services/logger.test.ts-502-    });
src/services/logger.test.ts-503-
src/services/logger.test.ts-504-    test('✅ should handle circular references in context', () => {
src/services/logger.test.ts:505:      const circular: any = { name: 'test' };
src/services/logger.test.ts-506-      circular.self = circular;
src/services/logger.test.ts-507-      
src/services/logger.test.ts-508-      // Should not throw
--
src/services/logger.test.ts-552-      
src/services/logger.test.ts-553-      const expensiveContext = () => {
src/services/logger.test.ts-554-        // Simulate expensive operation
src/services/logger.test.ts:555:        const result: any = {};
src/services/logger.test.ts-556-        for (let i = 0; i < 1000; i++) {
src/services/logger.test.ts-557-          result[`key${i}`] = `value${i}`;
src/services/logger.test.ts-558-        }
--
src/services/CircuitBreaker.test.ts-22-
src/services/CircuitBreaker.test.ts-23-describe('CircuitBreaker - Production Tests', () => {
src/services/CircuitBreaker.test.ts-24-  let circuitBreaker: CircuitBreaker;
src/services/CircuitBreaker.test.ts:25:  let mockService: any;
src/services/CircuitBreaker.test.ts-26-  let callCount = 0;
src/services/CircuitBreaker.test.ts-27-
src/services/CircuitBreaker.test.ts-28-  beforeEach(() => {
--
src/services/CircuitBreaker.test.ts-208-      try {
src/services/CircuitBreaker.test.ts-209-        await circuitBreaker.execute(mockService.successfulCall);
src/services/CircuitBreaker.test.ts-210-        expect.unreachable('Should have thrown error');
src/services/CircuitBreaker.test.ts:211:      } catch (error: any) {
src/services/CircuitBreaker.test.ts-212-        expect(error.message).toBe('Circuit breaker is OPEN');
src/services/CircuitBreaker.test.ts-213-        expect(error.circuitBreakerState).toBe('OPEN');
src/services/CircuitBreaker.test.ts-214-        expect(error.serviceName).toBe('open-test');
--
src/services/CircuitBreaker.test.ts-484-    });
src/services/CircuitBreaker.test.ts-485-
src/services/CircuitBreaker.test.ts-486-    test('should handle null/undefined function gracefully', async () => {
src/services/CircuitBreaker.test.ts:487:      await expect(circuitBreaker.execute(null as any))
src/services/CircuitBreaker.test.ts-488-        .rejects.toThrow('Function is required');
src/services/CircuitBreaker.test.ts-489-      
src/services/CircuitBreaker.test.ts:490:      await expect(circuitBreaker.execute(undefined as any))
src/services/CircuitBreaker.test.ts-491-        .rejects.toThrow('Function is required');
src/services/CircuitBreaker.test.ts-492-    });
src/services/CircuitBreaker.test.ts-493-
src/services/CircuitBreaker.test.ts-494-    test('should handle non-function arguments', async () => {
src/services/CircuitBreaker.test.ts:495:      await expect(circuitBreaker.execute('not a function' as any))
src/services/CircuitBreaker.test.ts-496-        .rejects.toThrow('Function is required');
src/services/CircuitBreaker.test.ts-497-      
src/services/CircuitBreaker.test.ts:498:      await expect(circuitBreaker.execute(123 as any))
src/services/CircuitBreaker.test.ts-499-        .rejects.toThrow('Function is required');
src/services/CircuitBreaker.test.ts-500-    });
src/services/CircuitBreaker.test.ts-501-
src/services/CircuitBreaker.test.ts-502-    test('should preserve original error information', async () => {
src/services/CircuitBreaker.test.ts-503-      const originalError = new Error('Original service error');
src/services/CircuitBreaker.test.ts-504-      originalError.stack = 'Original stack trace';
src/services/CircuitBreaker.test.ts:505:      (originalError as any).statusCode = 500;
src/services/CircuitBreaker.test.ts-506-
src/services/CircuitBreaker.test.ts-507-      const failingService = mock(async () => {
src/services/CircuitBreaker.test.ts-508-        throw originalError;
--
src/services/CircuitBreaker.test.ts-511-      try {
src/services/CircuitBreaker.test.ts-512-        await circuitBreaker.execute(failingService);
src/services/CircuitBreaker.test.ts-513-        expect.unreachable('Should have thrown error');
src/services/CircuitBreaker.test.ts:514:      } catch (error: any) {
src/services/CircuitBreaker.test.ts-515-        expect(error.message).toBe('Original service error');
src/services/CircuitBreaker.test.ts-516-        expect(error.statusCode).toBe(500);
src/services/CircuitBreaker.test.ts-517-        expect(error.stack).toContain('Original stack trace');
--
src/services/instagram-stories-manager.ts-391-    dateRange?: { from: Date; to: Date }
src/services/instagram-stories-manager.ts-392-  ): Promise<StoryAnalytics> {
src/services/instagram-stories-manager.ts-393-    try {
src/services/instagram-stories-manager.ts:394:      const sql = this.db.getSQL() as any;
src/services/instagram-stories-manager.ts-395-
src/services/instagram-stories-manager.ts-396-      const dateFilter = dateRange 
src/services/instagram-stories-manager.ts-397-        ? sql`AND created_at BETWEEN ${dateRange.from.toISOString()} AND ${dateRange.to.toISOString()}`
--
src/services/instagram-stories-manager.ts-477-    template: Omit<StoryTemplate, 'id'>
src/services/instagram-stories-manager.ts-478-  ): Promise<string> {
src/services/instagram-stories-manager.ts-479-    try {
src/services/instagram-stories-manager.ts:480:      const sql = this.db.getSQL() as any;
src/services/instagram-stories-manager.ts-481-
src/services/instagram-stories-manager.ts-482-      const result = await sql`
src/services/instagram-stories-manager.ts-483-        INSERT INTO story_templates (
--
src/services/instagram-stories-manager.ts-515-    category?: string
src/services/instagram-stories-manager.ts-516-  ): Promise<StoryTemplate[]> {
src/services/instagram-stories-manager.ts-517-    try {
src/services/instagram-stories-manager.ts:518:      const sql = this.db.getSQL() as any;
src/services/instagram-stories-manager.ts-519-
src/services/instagram-stories-manager.ts-520-      const categoryFilter = category 
src/services/instagram-stories-manager.ts-521-        ? sql`AND category = ${category}`
--
src/services/instagram-stories-manager.ts-552-    merchantId: string
src/services/instagram-stories-manager.ts-553-  ): Promise<void> {
src/services/instagram-stories-manager.ts-554-    try {
src/services/instagram-stories-manager.ts:555:      const sql = this.db.getSQL() as any;
src/services/instagram-stories-manager.ts-556-
src/services/instagram-stories-manager.ts-557-      await sql`
src/services/instagram-stories-manager.ts-558-        INSERT INTO story_interactions (
--
src/services/instagram-stories-manager.ts-598-    username?: string
src/services/instagram-stories-manager.ts-599-  ): Promise<{ id: string; isNew: boolean } | null> {
src/services/instagram-stories-manager.ts-600-    try {
src/services/instagram-stories-manager.ts:601:      const sql = this.db.getSQL() as any;
src/services/instagram-stories-manager.ts-602-
src/services/instagram-stories-manager.ts-603-      // Try to find existing conversation
src/services/instagram-stories-manager.ts-604-      const existing = await sql`
--
src/services/instagram-stories-manager.ts-659-    conversationId: string
src/services/instagram-stories-manager.ts-660-  ): Promise<InstagramContext> {
src/services/instagram-stories-manager.ts-661-    try {
src/services/instagram-stories-manager.ts:662:      const sql = this.db.getSQL() as any;
src/services/instagram-stories-manager.ts-663-
src/services/instagram-stories-manager.ts-664-      // Get merchant and conversation data
src/services/instagram-stories-manager.ts-665-      const data = await sql`
--
src/services/instagram-stories-manager.ts-689-        LIMIT 5
src/services/instagram-stories-manager.ts-690-        `;
src/services/instagram-stories-manager.ts-691-
src/services/instagram-stories-manager.ts:692:        let session: any = {};
src/services/instagram-stories-manager.ts-693-        try {
src/services/instagram-stories-manager.ts-694-          session = typeof conversation.session_data === 'string'
src/services/instagram-stories-manager.ts-695-            ? JSON.parse(conversation.session_data)
--
src/services/instagram-stories-manager.ts-711-          timestamp: new Date(msg.timestamp)
src/services/instagram-stories-manager.ts-712-        })),
src/services/instagram-stories-manager.ts-713-        // ✅ فلترة لأنواع التفاعل المدعومة فقط
src/services/instagram-stories-manager.ts:714:        interactionType: (['story_reply','story_mention','story_reaction'] as const).includes(interaction.type as any)
src/services/instagram-stories-manager.ts-715-          ? (interaction.type as 'story_reply' | 'story_mention' | 'story_reaction')
src/services/instagram-stories-manager.ts-716-          : 'story_mention',
src/services/instagram-stories-manager.ts-717-        mediaContext: { mediaId: interaction.storyId },
--
src/services/instagram-stories-manager.ts-808-    messageId?: string
src/services/instagram-stories-manager.ts-809-  ): Promise<void> {
src/services/instagram-stories-manager.ts-810-    try {
src/services/instagram-stories-manager.ts:811:      const sql = this.db.getSQL() as any;
src/services/instagram-stories-manager.ts-812-
src/services/instagram-stories-manager.ts-813-      await sql`
src/services/instagram-stories-manager.ts-814-        INSERT INTO message_logs (
--
src/services/instagram-stories-manager.ts-861-    interaction: StoryInteraction
src/services/instagram-stories-manager.ts-862-  ): Promise<void> {
src/services/instagram-stories-manager.ts-863-    try {
src/services/instagram-stories-manager.ts:864:      const sql = this.db.getSQL() as any;
src/services/instagram-stories-manager.ts-865-      const redis = await this.redis.getConnection(RedisUsageType.CACHING);
src/services/instagram-stories-manager.ts-866-
src/services/instagram-stories-manager.ts-867-      // Ensure unique users per day using Redis set
--
src/services/instagram-stories-manager.ts-908-    interactionType: string
src/services/instagram-stories-manager.ts-909-  ): Promise<void> {
src/services/instagram-stories-manager.ts-910-    try {
src/services/instagram-stories-manager.ts:911:      const sql = this.db.getSQL() as any;
src/services/instagram-stories-manager.ts-912-
src/services/instagram-stories-manager.ts-913-      await sql`
src/services/instagram-stories-manager.ts-914-        INSERT INTO sales_opportunities (
--
src/tests/sql-injection.test.ts-11-
src/tests/sql-injection.test.ts-12-describe('Database query sanitization', () => {
src/tests/sql-injection.test.ts-13-  let manager: CrossPlatformConversationManager;
src/tests/sql-injection.test.ts:14:  let sql: any;
src/tests/sql-injection.test.ts-15-
src/tests/sql-injection.test.ts-16-  beforeAll(async () => {
src/tests/sql-injection.test.ts-17-    const db = await initializeDatabase();
--
src/services/RedisConnectionManager.ts-66-  constructor(
src/services/RedisConnectionManager.ts-67-    private redisUrl: string,
src/services/RedisConnectionManager.ts-68-    private environment: Environment,
src/services/RedisConnectionManager.ts:69:    private logger?: any,
src/services/RedisConnectionManager.ts-70-    poolConfig?: Partial<ConnectionPoolConfig>
src/services/RedisConnectionManager.ts-71-  ) {
src/services/RedisConnectionManager.ts-72-    this.configFactory = new ProductionRedisConfigurationFactory();
--
src/services/RedisConnectionManager.ts-367-      const connection = await this.getConnection(usageType);
src/services/RedisConnectionManager.ts-368-      const result = await callback(connection);
src/services/RedisConnectionManager.ts-369-      return { ok: true, result };
src/services/RedisConnectionManager.ts:370:    } catch (error: any) {
src/services/RedisConnectionManager.ts-371-      const processedError = this.errorHandler.handleError(error, {
src/services/RedisConnectionManager.ts-372-        usageType,
src/services/RedisConnectionManager.ts-373-        operation
--
src/services/RedisConnectionManager.ts-496-            });
src/services/RedisConnectionManager.ts-497-          }
src/services/RedisConnectionManager.ts-498-        }
src/services/RedisConnectionManager.ts:499:      } catch (error: any) {
src/services/RedisConnectionManager.ts-500-        info.status = 'error';
src/services/RedisConnectionManager.ts-501-        info.healthScore = 0;
src/services/RedisConnectionManager.ts-502-        info.lastError = error.message;
--
src/services/RedisConnectionManager.ts-520-    this.healthCheckInterval = setInterval(async () => {
src/services/RedisConnectionManager.ts-521-      try {
src/services/RedisConnectionManager.ts-522-        await this.performHealthCheckOnAllConnections();
src/services/RedisConnectionManager.ts:523:      } catch (error: any) {
src/services/RedisConnectionManager.ts-524-        this.logger?.error('Scheduled health check failed', { error: error.message });
src/services/RedisConnectionManager.ts-525-      }
src/services/RedisConnectionManager.ts-526-    }, this.poolConfig.healthCheckInterval);
--
src/repositories/conversation-repository.ts-250-   */
src/repositories/conversation-repository.ts-251-  async update(id: string, data: UpdateConversationRequest): Promise<Conversation | null> {
src/repositories/conversation-repository.ts-252-    const updateFields: string[] = [];
src/repositories/conversation-repository.ts:253:    const updateValues: any[] = [];
src/repositories/conversation-repository.ts-254-    let paramIndex = 1;
src/repositories/conversation-repository.ts-255-
src/repositories/conversation-repository.ts-256-    if (data.conversationStage !== undefined) {
--
src/repositories/conversation-repository.ts-315-   */
src/repositories/conversation-repository.ts-316-  async findMany(filters: ConversationFilters = {}): Promise<Conversation[]> {
src/repositories/conversation-repository.ts-317-    let whereConditions: string[] = [];
src/repositories/conversation-repository.ts:318:    let params: any[] = [];
src/repositories/conversation-repository.ts-319-    let paramIndex = 1;
src/repositories/conversation-repository.ts-320-
src/repositories/conversation-repository.ts-321-    if (filters.merchantId) {
--
src/repositories/conversation-repository.ts-383-   */
src/repositories/conversation-repository.ts-384-  async getStats(merchantId?: string, dateFrom?: Date, dateTo?: Date): Promise<ConversationStats> {
src/repositories/conversation-repository.ts-385-    let whereConditions: string[] = [];
src/repositories/conversation-repository.ts:386:    let params: any[] = [];
src/repositories/conversation-repository.ts-387-    let paramIndex = 1;
src/repositories/conversation-repository.ts-388-
src/repositories/conversation-repository.ts-389-    if (merchantId) {
--
src/repositories/conversation-repository.ts-470-   */
src/repositories/conversation-repository.ts-471-  async count(filters: ConversationFilters = {}): Promise<number> {
src/repositories/conversation-repository.ts-472-    let whereConditions: string[] = [];
src/repositories/conversation-repository.ts:473:    let params: any[] = [];
src/repositories/conversation-repository.ts-474-    let paramIndex = 1;
src/repositories/conversation-repository.ts-475-
src/repositories/conversation-repository.ts-476-    if (filters.merchantId) {
--
src/services/redis-monitoring.ts-42-}
src/services/redis-monitoring.ts-43-
src/services/redis-monitoring.ts-44-export class RedisMonitor {
src/services/redis-monitoring.ts:45:  private redis: any;
src/services/redis-monitoring.ts-46-  private alerts: RedisAlerts = {
src/services/redis-monitoring.ts-47-    highMemoryUsage: false,
src/services/redis-monitoring.ts-48-    slowResponseTime: false,
--
src/services/redis-monitoring.ts-50-    highErrorRate: false
src/services/redis-monitoring.ts-51-  };
src/services/redis-monitoring.ts-52-
src/services/redis-monitoring.ts:53:  constructor(redisConnection?: any) {
src/services/redis-monitoring.ts-54-    this.redis = redisConnection;
src/services/redis-monitoring.ts-55-  }
src/services/redis-monitoring.ts-56-
src/services/redis-monitoring.ts:57:  setRedisConnection(redis: any): void {
src/services/redis-monitoring.ts-58-    this.redis = redis;
src/services/redis-monitoring.ts-59-  }
src/services/redis-monitoring.ts-60-
--
src/services/redis-monitoring.ts-201-/**
src/services/redis-monitoring.ts-202- * Get Redis monitor instance
src/services/redis-monitoring.ts-203- */
src/services/redis-monitoring.ts:204:export function getRedisMonitor(redisConnection?: any): RedisMonitor {
src/services/redis-monitoring.ts-205-  if (!redisMonitorInstance) {
src/services/redis-monitoring.ts-206-    redisMonitorInstance = new RedisMonitor(redisConnection);
src/services/redis-monitoring.ts-207-  } else if (redisConnection) {
--
src/services/ProductionQueueManager.ts-8-  let settled = false;
src/services/ProductionQueueManager.ts-9-  return {
src/services/ProductionQueueManager.ts-10-    guardResolve:
src/services/ProductionQueueManager.ts:11:      (resolve: (v: T) => void, reject: (e: any) => void, clear?: () => void) =>
src/services/ProductionQueueManager.ts-12-      (v: T) => {
src/services/ProductionQueueManager.ts-13-        if (settled) return;
src/services/ProductionQueueManager.ts-14-        settled = true;
--
src/services/ProductionQueueManager.ts-16-        resolve(v);
src/services/ProductionQueueManager.ts-17-      },
src/services/ProductionQueueManager.ts-18-    guardReject:
src/services/ProductionQueueManager.ts:19:      (resolve: (v: T) => void, reject: (e: any) => void, clear?: () => void) =>
src/services/ProductionQueueManager.ts:20:      (e: any) => {
src/services/ProductionQueueManager.ts-21-        if (settled) return;
src/services/ProductionQueueManager.ts-22-        settled = true;
src/services/ProductionQueueManager.ts-23-        clear?.();
--
src/services/ProductionQueueManager.ts-61-
src/services/ProductionQueueManager.ts-62-export interface QueueJob {
src/services/ProductionQueueManager.ts-63-  eventId: string;
src/services/ProductionQueueManager.ts:64:  payload: any;
src/services/ProductionQueueManager.ts-65-  merchantId: string;
src/services/ProductionQueueManager.ts-66-  platform: 'INSTAGRAM' | 'WHATSAPP' | 'FACEBOOK';
src/services/ProductionQueueManager.ts-67-  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
--
src/services/ProductionQueueManager.ts-72-  success: boolean;
src/services/ProductionQueueManager.ts-73-  queue: Queue | null;
src/services/ProductionQueueManager.ts-74-  error?: string;
src/services/ProductionQueueManager.ts:75:  connectionInfo?: any;
src/services/ProductionQueueManager.ts-76-  diagnostics?: {
src/services/ProductionQueueManager.ts:77:    redisConnection?: any;
src/services/ProductionQueueManager.ts:78:    queueHealth?: any;
src/services/ProductionQueueManager.ts:79:    circuitBreaker?: any;
src/services/ProductionQueueManager.ts-80-  };
src/services/ProductionQueueManager.ts-81-}
src/services/ProductionQueueManager.ts-82-
--
src/services/ProductionQueueManager.ts-131-
src/services/ProductionQueueManager.ts-132-  constructor(
src/services/ProductionQueueManager.ts-133-    private redisUrl: string,
src/services/ProductionQueueManager.ts:134:    private logger: any,
src/services/ProductionQueueManager.ts-135-    private environment: Environment,
src/services/ProductionQueueManager.ts-136-    private dbPool: Pool,
src/services/ProductionQueueManager.ts-137-    private queueName: string = 'ai-sales-production'
--
src/services/ProductionQueueManager.ts-841-
src/services/ProductionQueueManager.ts-842-  async addWebhookJob(
src/services/ProductionQueueManager.ts-843-    eventId: string,
src/services/ProductionQueueManager.ts:844:    payload: any,
src/services/ProductionQueueManager.ts-845-    merchantId: string,
src/services/ProductionQueueManager.ts-846-    platform: 'INSTAGRAM' | 'WHATSAPP' | 'FACEBOOK',
src/services/ProductionQueueManager.ts-847-    priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'MEDIUM'
--
src/services/ProductionQueueManager.ts-1241-    }
src/services/ProductionQueueManager.ts-1242-  }
src/services/ProductionQueueManager.ts-1243-
src/services/ProductionQueueManager.ts:1244:  private async processAIResponseJob(jobData: any): Promise<any> {
src/services/ProductionQueueManager.ts-1245-    const startTime = Date.now();
src/services/ProductionQueueManager.ts-1246-    
src/services/ProductionQueueManager.ts-1247-    try {
--
src/services/ProductionQueueManager.ts-1270-      const platform = (jobData.platform?.toLowerCase() || 'instagram') as 'instagram' | 'whatsapp';
src/services/ProductionQueueManager.ts-1271-      
src/services/ProductionQueueManager.ts-1272-      // إنشاء context حسب platform
src/services/ProductionQueueManager.ts:1273:      let context: any;
src/services/ProductionQueueManager.ts-1274-      
src/services/ProductionQueueManager.ts-1275-      if (platform === 'instagram') {
src/services/ProductionQueueManager.ts-1276-        context = {
--
src/services/ProductionQueueManager.ts-1588-  async getQueueHealth(): Promise<{
src/services/ProductionQueueManager.ts-1589-    healthy: boolean;
src/services/ProductionQueueManager.ts-1590-    stats: QueueStats;
src/services/ProductionQueueManager.ts:1591:    redisHealth: any;
src/services/ProductionQueueManager.ts-1592-    workerStatus: {
src/services/ProductionQueueManager.ts-1593-      isProcessing: boolean;
src/services/ProductionQueueManager.ts-1594-      delayedJobs: number;
--
src/services/ProductionQueueManager.ts-1766-   * بناء context متقدم للذكاء الاصطناعي
src/services/ProductionQueueManager.ts-1767-   */
src/services/ProductionQueueManager.ts-1768-  private async buildAdvancedAIContext(
src/services/ProductionQueueManager.ts:1769:    jobData: any,
src/services/ProductionQueueManager.ts-1770-    conversation: Record<string, unknown>,
src/services/ProductionQueueManager.ts-1771-    merchant: Record<string, unknown>,
src/services/ProductionQueueManager.ts-1772-    messageHistory: Record<string, unknown>[]
--
src/services/ProductionQueueManager.ts-1778-      stage: conversation.conversationStage,
src/services/ProductionQueueManager.ts-1779-      cart: conversation.sessionData?.cart || [],
src/services/ProductionQueueManager.ts-1780-      preferences: conversation.sessionData?.preferences || {},
src/services/ProductionQueueManager.ts:1781:      conversationHistory: messageHistory.map((msg: any) => ({
src/services/ProductionQueueManager.ts-1782-        role: msg.direction === 'INCOMING' ? 'user' : 'assistant',
src/services/ProductionQueueManager.ts-1783-        content: msg.content,
src/services/ProductionQueueManager.ts-1784-        timestamp: msg.createdAt
--
src/services/ProductionQueueManager.ts-1813-   * إرسال رسالة AI عبر منصة API
src/services/ProductionQueueManager.ts-1814-   */
src/services/ProductionQueueManager.ts-1815-  private async deliverAIMessage(
src/services/ProductionQueueManager.ts:1816:    jobData: any,
src/services/ProductionQueueManager.ts-1817-    message: string
src/services/ProductionQueueManager.ts-1818-  ): Promise<{ success: boolean; platformMessageId?: string; error?: string }> {
src/services/ProductionQueueManager.ts-1819-    try {
--
src/services/ProductionQueueManager.ts-1839-   * إرسال رسالة Instagram AI
src/services/ProductionQueueManager.ts-1840-   */
src/services/ProductionQueueManager.ts-1841-  private async deliverInstagramAIMessage(
src/services/ProductionQueueManager.ts:1842:    jobData: any,
src/services/ProductionQueueManager.ts-1843-    message: string
src/services/ProductionQueueManager.ts-1844-  ): Promise<{ success: boolean; platformMessageId?: string; error?: string }> {
src/services/ProductionQueueManager.ts-1845-    try {
--
src/services/ProductionQueueManager.ts-1872-  /**
src/services/ProductionQueueManager.ts-1873-   * معالجة مهام الإشعارات
src/services/ProductionQueueManager.ts-1874-   */
src/services/ProductionQueueManager.ts:1875:  private async processNotificationJob(jobData: any): Promise<any> {
src/services/ProductionQueueManager.ts-1876-    const startTime = Date.now();
src/services/ProductionQueueManager.ts-1877-    
src/services/ProductionQueueManager.ts-1878-    try {
--
src/services/ProductionQueueManager.ts-1937-  /**
src/services/ProductionQueueManager.ts-1938-   * معالجة مهام تسليم الرسائل
src/services/ProductionQueueManager.ts-1939-   */
src/services/ProductionQueueManager.ts:1940:  private async processMessageDeliveryJob(jobData: any): Promise<any> {
src/services/ProductionQueueManager.ts-1941-    const startTime = Date.now();
src/services/ProductionQueueManager.ts-1942-    
src/services/ProductionQueueManager.ts-1943-    try {
--
src/services/instagram-setup.ts-33-  step: string;
src/services/instagram-setup.ts-34-  status: 'pending' | 'in_progress' | 'completed' | 'failed';
src/services/instagram-setup.ts-35-  message: string;
src/services/instagram-setup.ts:36:  details?: any;
src/services/instagram-setup.ts-37-}
src/services/instagram-setup.ts-38-
src/services/instagram-setup.ts-39-export interface BusinessAccountInfo {
--
src/services/instagram-setup.ts-215-          'validation'
src/services/instagram-setup.ts-216-        );
src/services/instagram-setup.ts-217-        const requiredPerms = ['instagram_basic', 'pages_messaging'];
src/services/instagram-setup.ts:218:        const grantedPerms = (permissions as any).data?.map((p: any) => p.permission) ?? [];
src/services/instagram-setup.ts-219-
src/services/instagram-setup.ts-220-        const missingPerms = requiredPerms.filter(perm => !grantedPerms.includes(perm));
src/services/instagram-setup.ts-221-        if (missingPerms.length > 0) {
--
src/services/instagram-setup.ts-361-  ): Promise<{
src/services/instagram-setup.ts-362-    success: boolean;
src/services/instagram-setup.ts-363-    accountInfo?: BusinessAccountInfo;
src/services/instagram-setup.ts:364:    healthStatus?: any;
src/services/instagram-setup.ts-365-    errors: string[];
src/services/instagram-setup.ts-366-  }> {
src/services/instagram-setup.ts-367-    const errors: string[] = [];
--
src/tests/rls-wrapper.test.ts-7-    const ids = new Set<string>();
src/tests/rls-wrapper.test.ts-8-
src/tests/rls-wrapper.test.ts-9-    for (let i = 0; i < 100; i++) {
src/tests/rls-wrapper.test.ts:10:      const id = (db as any).generateSessionId();
src/tests/rls-wrapper.test.ts-11-      expect(ids.has(id)).toBe(false);
src/tests/rls-wrapper.test.ts-12-      ids.add(id);
src/tests/rls-wrapper.test.ts-13-    }
--
src/services/ai.test.ts-95-    });
src/services/ai.test.ts-96-
src/services/ai.test.ts-97-    // Mock OpenAI constructor and methods
src/services/ai.test.ts:98:    (OpenAI as jest.MockedClass<typeof OpenAI>).mockImplementation(() => mockOpenAI as any);
src/services/ai.test.ts-99-
src/services/ai.test.ts-100-    aiService = new AIService();
src/services/ai.test.ts-101-  });
--
src/services/ai.test.ts-598-      const responses = new Set();
src/services/ai.test.ts-599-      
src/services/ai.test.ts-600-      for (let i = 0; i < 20; i++) {
src/services/ai.test.ts:601:        const response = (aiService as any).getFallbackResponse(sampleContext);
src/services/ai.test.ts-602-        responses.add(response.message);
src/services/ai.test.ts-603-      }
src/services/ai.test.ts-604-
--
src/services/ai.test.ts-607-    });
src/services/ai.test.ts-608-
src/services/ai.test.ts-609-    test('✅ should maintain proper fallback structure', () => {
src/services/ai.test.ts:610:      const response = (aiService as any).getFallbackResponse(sampleContext);
src/services/ai.test.ts-611-
src/services/ai.test.ts-612-      expect(response).toMatchObject({
src/services/ai.test.ts-613-        intent: 'SUPPORT',
--
src/services/ai.test.ts-631-
src/services/ai.test.ts-632-    test('✅ should create instance if not exists', () => {
src/services/ai.test.ts-633-      // Reset singleton
src/services/ai.test.ts:634:      (require('./ai.js') as any).aiServiceInstance = null;
src/services/ai.test.ts-635-
src/services/ai.test.ts-636-      const instance = getAIService();
src/services/ai.test.ts-637-      expect(instance).toBeInstanceOf(AIService);
--
src/tests/instagram-integration.test.ts-22-    default: class OpenAI {
src/tests/instagram-integration.test.ts-23-      chat = {
src/tests/instagram-integration.test.ts-24-        completions: {
src/tests/instagram-integration.test.ts:25:          create: async (params: any) => ({
src/tests/instagram-integration.test.ts-26-            choices: [{
src/tests/instagram-integration.test.ts-27-              message: {
src/tests/instagram-integration.test.ts-28-                content: JSON.stringify({
src/tests/instagram-integration.test.ts:29:                  message: params.messages.some((m: any) => m.content?.includes('منتجات')) 
src/tests/instagram-integration.test.ts-30-                    ? 'نعم، لدينا منتجات جديدة رائعة!' 
src/tests/instagram-integration.test.ts-31-                    : 'شكرًا على اهتمامك! يرجى مراسلتنا في الخاص للحصول على تفاصيل السعر.',
src/tests/instagram-integration.test.ts-32-                  intent: 'PRODUCT_INQUIRY',
src/tests/instagram-integration.test.ts-33-                  confidence: 0.85,
src/tests/instagram-integration.test.ts-34-                  products: [],
src/tests/instagram-integration.test.ts:35:                  visualStyle: params.messages.some((m: any) => m.content?.includes('comment')) ? 'post' : 'dm'
src/tests/instagram-integration.test.ts-36-                })
src/tests/instagram-integration.test.ts-37-              }
src/tests/instagram-integration.test.ts-38-            }]
--
src/tests/instagram-integration.test.ts-47-mock.module('../middleware/security.js', () => {
src/tests/instagram-integration.test.ts-48-  const limiter = new RateLimiterMemory({ points: 3, duration: 60 });
src/tests/instagram-integration.test.ts-49-  return {
src/tests/instagram-integration.test.ts:50:    securityHeaders: async (_c: any, next: any) => {
src/tests/instagram-integration.test.ts-51-      await next();
src/tests/instagram-integration.test.ts-52-    },
src/tests/instagram-integration.test.ts:53:    rateLimiter: async (c: any, next: any) => {
src/tests/instagram-integration.test.ts-54-      const key = c.req.header('x-rate-key') || 'default';
src/tests/instagram-integration.test.ts-55-      try {
src/tests/instagram-integration.test.ts-56-        await limiter.consume(key);
--
src/tests/instagram-integration.test.ts-74-const TEST_CUSTOMER_INSTAGRAM = 'test_customer_123';
src/tests/instagram-integration.test.ts-75-
src/tests/instagram-integration.test.ts-76-describe('Instagram Integration Tests', () => {
src/tests/instagram-integration.test.ts:77:  let db: any;
src/tests/instagram-integration.test.ts:78:  let sql: any;
src/tests/instagram-integration.test.ts-79-  
src/tests/instagram-integration.test.ts-80-  beforeAll(async () => {
src/tests/instagram-integration.test.ts-81-    // Setup test database
--
src/tests/instagram-integration.test.ts-500-      const { getWebhookRouter } = await import('../api/webhooks.js');
src/tests/instagram-integration.test.ts-501-      const router = getWebhookRouter();
src/tests/instagram-integration.test.ts-502-      let processed = 0;
src/tests/instagram-integration.test.ts:503:      (router as any).processInstagramEntry = async () => { processed++; };
src/tests/instagram-integration.test.ts-504-      const app = router.getApp();
src/tests/instagram-integration.test.ts-505-      const event = { object: 'instagram', entry: [{ id: 'page_1', time: 123, messaging: [] }] };
src/tests/instagram-integration.test.ts-506-      const headers = {
--
src/tests/instagram-integration.test.ts-531-    test('should respond with 429 when rate limit exceeded', async () => {
src/tests/instagram-integration.test.ts-532-      const { getWebhookRouter } = await import('../api/webhooks.js');
src/tests/instagram-integration.test.ts-533-      const router = getWebhookRouter();
src/tests/instagram-integration.test.ts:534:      (router as any).processInstagramEntry = async () => {};
src/tests/instagram-integration.test.ts-535-      const app = router.getApp();
src/tests/instagram-integration.test.ts-536-      const event = { object: 'instagram', entry: [{ id: 'page_1', time: 456, messaging: [] }] };
src/tests/instagram-integration.test.ts-537-      const headers = {
--
src/tests/instagram-oauth.test.ts-44-
src/tests/instagram-oauth.test.ts-45-// In-memory session store to simulate database
src/tests/instagram-oauth.test.ts-46-const sessions: Record<string, any> = {};
src/tests/instagram-oauth.test.ts:47:const sql = async (strings: TemplateStringsArray, ...values: any[]) => {
src/tests/instagram-oauth.test.ts-48-  const query = strings.join(' ');
src/tests/instagram-oauth.test.ts-49-  if (query.includes('INSERT INTO oauth_sessions')) {
src/tests/instagram-oauth.test.ts-50-    const [merchantId, state, codeVerifier, codeChallenge, redirectUri] = values;
--
src/tests/instagram-oauth.test.ts-99-
src/tests/instagram-oauth.test.ts-100-afterEach(() => {
src/tests/instagram-oauth.test.ts-101-  mock.restore();
src/tests/instagram-oauth.test.ts:102:  delete (globalThis as any).fetch;
src/tests/instagram-oauth.test.ts-103-});
src/tests/instagram-oauth.test.ts-104-
src/tests/instagram-oauth.test.ts-105-describe('Instagram OAuth', () => {
--
src/tests/instagram-oauth.test.ts-118-
src/tests/instagram-oauth.test.ts-119-  test('exchangeCode handles invalid code', async () => {
src/tests/instagram-oauth.test.ts-120-    const service = new InstagramOAuthService();
src/tests/instagram-oauth.test.ts:121:    (globalThis as any).fetch = mock(async () => ({
src/tests/instagram-oauth.test.ts-122-      ok: false,
src/tests/instagram-oauth.test.ts-123-      status: 400,
src/tests/instagram-oauth.test.ts-124-      text: async () => 'bad code'
--
src/tests/instagram-oauth.test.ts-130-
src/tests/instagram-oauth.test.ts-131-  test('exchangeCode returns access token on success', async () => {
src/tests/instagram-oauth.test.ts-132-    const service = new InstagramOAuthService();
src/tests/instagram-oauth.test.ts:133:    (service as any).exchangeForLongLivedToken = mock(async () => ({
src/tests/instagram-oauth.test.ts-134-      access_token: 'long',
src/tests/instagram-oauth.test.ts-135-      token_type: 'bearer',
src/tests/instagram-oauth.test.ts-136-      expires_in: 3600
src/tests/instagram-oauth.test.ts-137-    }));
src/tests/instagram-oauth.test.ts:138:    (globalThis as any).fetch = mock(async () => ({
src/tests/instagram-oauth.test.ts-139-      ok: true,
src/tests/instagram-oauth.test.ts-140-      json: async () => ({ access_token: 'short', user_id: 123 })
src/tests/instagram-oauth.test.ts-141-    }));
--
src/tests/hashtag-growth.test.ts-2-import { InstagramHashtagMentionProcessor } from '../services/instagram-hashtag-mention-processor.js';
src/tests/hashtag-growth.test.ts-3-
src/tests/hashtag-growth.test.ts-4-function createContext(result: { current_count: number; previous_count: number }) {
src/tests/hashtag-growth.test.ts:5:  const sqlStub = { unsafe: async () => [result] } as any;
src/tests/hashtag-growth.test.ts-6-  return {
src/tests/hashtag-growth.test.ts-7-    db: { getSQL: () => sqlStub },
src/tests/hashtag-growth.test.ts-8-    getTimeFilter: InstagramHashtagMentionProcessor.prototype.getTimeFilter
src/tests/hashtag-growth.test.ts:9:  } as any;
src/tests/hashtag-growth.test.ts-10-}
src/tests/hashtag-growth.test.ts-11-
src/tests/hashtag-growth.test.ts-12-describe('calculateHashtagGrowth', () => {
src/tests/hashtag-growth.test.ts-13-  test('returns positive growth percentage', async () => {
src/tests/hashtag-growth.test.ts-14-    const ctx = createContext({ current_count: 15, previous_count: 10 });
src/tests/hashtag-growth.test.ts:15:    const growth = await (InstagramHashtagMentionProcessor.prototype as any).calculateHashtagGrowth.call(
src/tests/hashtag-growth.test.ts-16-      ctx,
src/tests/hashtag-growth.test.ts-17-      '#test',
src/tests/hashtag-growth.test.ts-18-      'merchant',
--
src/tests/hashtag-growth.test.ts-23-
src/tests/hashtag-growth.test.ts-24-  test('returns negative growth percentage', async () => {
src/tests/hashtag-growth.test.ts-25-    const ctx = createContext({ current_count: 5, previous_count: 10 });
src/tests/hashtag-growth.test.ts:26:    const growth = await (InstagramHashtagMentionProcessor.prototype as any).calculateHashtagGrowth.call(
src/tests/hashtag-growth.test.ts-27-      ctx,
src/tests/hashtag-growth.test.ts-28-      '#test',
src/tests/hashtag-growth.test.ts-29-      'merchant',
--
src/tests/hashtag-growth.test.ts-34-
src/tests/hashtag-growth.test.ts-35-  test('handles zero previous count', async () => {
src/tests/hashtag-growth.test.ts-36-    const ctx = createContext({ current_count: 5, previous_count: 0 });
src/tests/hashtag-growth.test.ts:37:    const growth = await (InstagramHashtagMentionProcessor.prototype as any).calculateHashtagGrowth.call(
src/tests/hashtag-growth.test.ts-38-      ctx,
src/tests/hashtag-growth.test.ts-39-      '#test',
src/tests/hashtag-growth.test.ts-40-      'merchant',
--
src/tests/hashtag-growth.test.ts-45-
src/tests/hashtag-growth.test.ts-46-  test('returns 0 when no data present', async () => {
src/tests/hashtag-growth.test.ts-47-    const ctx = createContext({ current_count: 0, previous_count: 0 });
src/tests/hashtag-growth.test.ts:48:    const growth = await (InstagramHashtagMentionProcessor.prototype as any).calculateHashtagGrowth.call(
src/tests/hashtag-growth.test.ts-49-      ctx,
src/tests/hashtag-growth.test.ts-50-      '#test',
src/tests/hashtag-growth.test.ts-51-      'merchant',
--
src/services/ai.ts-50-  customerId: string;
src/services/ai.ts-51-  platform: Platform;
src/services/ai.ts-52-  stage: ConversationStage;
src/services/ai.ts:53:  cart: any[];
src/services/ai.ts-54-  preferences: Record<string, any>;
src/services/ai.ts-55-  conversationHistory: MessageHistory[];
src/services/ai.ts-56-  customerProfile?: CustomerProfile;
--
src/services/ai.ts-77-export interface MerchantSettings {
src/services/ai.ts-78-  businessName: string;
src/services/ai.ts-79-  businessCategory: string;
src/services/ai.ts:80:  workingHours: any;
src/services/ai.ts-81-  paymentMethods: string[];
src/services/ai.ts:82:  deliveryFees: any;
src/services/ai.ts:83:  autoResponses: any;
src/services/ai.ts-84-}
src/services/ai.ts-85-
src/services/ai.ts-86-export class AIService {
src/services/ai.ts-87-  protected openai: OpenAI;
src/services/ai.ts:88:  private encryptionService: any;
src/services/ai.ts-89-  protected pool: Pool;
src/services/ai.ts-90-  private config: AppConfig;
src/services/ai.ts:91:  private logger: any;
src/services/ai.ts:92:  private db: any;
src/services/ai.ts-93-
src/services/ai.ts-94-  constructor(private container: DIContainer) {
src/services/ai.ts-95-    this.pool = container.get<Pool>('pool');
--
src/services/ai.ts-105-    });
src/services/ai.ts-106-
src/services/ai.ts-107-    // Get encryption service (will be injected later) — avoid unhandled rejection
src/services/ai.ts:108:    void this.initializeEncryptionService().catch((err: any) => {
src/services/ai.ts-109-      this.logger.error('Failed to initialize encryption service:', err);
src/services/ai.ts-110-    });
src/services/ai.ts-111-  }
--
src/services/ai.ts-114-    try {
src/services/ai.ts-115-      const { getEncryptionService } = await import('./encryption.js');
src/services/ai.ts-116-      this.encryptionService = getEncryptionService();
src/services/ai.ts:117:    } catch (error: any) {
src/services/ai.ts-118-      // لا تفشل خدمة الـ AI إذا ما تجهّز التشفير
src/services/ai.ts-119-      this.logger.error('Failed to initialize encryption service:', error);
src/services/ai.ts-120-    }
src/services/ai.ts-121-  }
src/services/ai.ts-122-
src/services/ai.ts-123-  /** Basic runtime validation for AIResponse payload */
src/services/ai.ts:124:  private validateAIResponse(payload: any): payload is AIResponse {
src/services/ai.ts-125-    return !!payload
src/services/ai.ts-126-      && typeof payload.message === 'string'
src/services/ai.ts-127-      && typeof payload.intent === 'string'
--
src/services/ai.ts-146-    while (attempt < max) {
src/services/ai.ts-147-      try {
src/services/ai.ts-148-        return await fn();
src/services/ai.ts:149:      } catch (e: any) {
src/services/ai.ts-150-        lastErr = e;
src/services/ai.ts-151-        const msg = String(e?.message || e);
src/services/ai.ts-152-        const retriable = /rate limit|timeout|ETIMEDOUT|ECONNRESET|ENETUNREACH|EAI_AGAIN/i.test(msg);
--
src/services/ai.ts-209-      ).finally(() => clearTimeout(timer));
src/services/ai.ts-210-
src/services/ai.ts-211-      const responseTime = Date.now() - startTime;
src/services/ai.ts:212:      const response = (completion as any).choices?.[0]?.message?.content;
src/services/ai.ts-213-
src/services/ai.ts-214-      if (!response) {
src/services/ai.ts-215-        throw new Error('No response from OpenAI');
src/services/ai.ts-216-      }
src/services/ai.ts-217-
src/services/ai.ts-218-      // Parse & validate AI response
src/services/ai.ts:219:      let aiResponse: any;
src/services/ai.ts-220-      try { aiResponse = JSON.parse(response); } catch (err) {
src/services/ai.ts-221-        this.logger.error("Invalid AI JSON response", { err });
src/services/ai.ts-222-        return this.getFallbackResponse(context);
--
src/services/ai.ts-238-      await this.logAIInteraction(context, this.maskPII(customerMessage), aiResponse);
src/services/ai.ts-239-
src/services/ai.ts-240-      return aiResponse;
src/services/ai.ts:241:    } catch (error: any) {
src/services/ai.ts-242-      this.logger.error('AI response generation failed:', {
src/services/ai.ts-243-        err: error?.message || String(error),
src/services/ai.ts-244-        stack: error?.stack,
--
src/services/ai.ts-272-        response_format: { type: 'json_object' }
src/services/ai.ts-273-      });
src/services/ai.ts-274-
src/services/ai.ts:275:      const response = (completion as any).choices?.[0]?.message?.content;
src/services/ai.ts-276-      return JSON.parse(response || '{}');
src/services/ai.ts:277:    } catch (error: any) {
src/services/ai.ts-278-      this.logger.error('❌ Intent analysis failed', error);
src/services/ai.ts-279-      return {
src/services/ai.ts-280-        intent: 'UNKNOWN',
--
src/services/ai.ts-311-        response_format: { type: 'json_object' }
src/services/ai.ts-312-      });
src/services/ai.ts-313-
src/services/ai.ts:314:      const response = (completion as any).choices?.[0]?.message?.content;
src/services/ai.ts-315-      const recommendations = JSON.parse(response || '{"recommendations": []}');
src/services/ai.ts-316-      
src/services/ai.ts-317-      return recommendations.recommendations.slice(0, maxProducts);
src/services/ai.ts:318:    } catch (error: any) {
src/services/ai.ts-319-      this.logger.error('❌ Product recommendation failed', error);
src/services/ai.ts-320-      return [];
src/services/ai.ts-321-    }
--
src/services/ai.ts-339-      });
src/services/ai.ts-340-
src/services/ai.ts-341-      return completion.choices[0]?.message?.content || 'لا يوجد ملخص متاح';
src/services/ai.ts:342:    } catch (error: any) {
src/services/ai.ts-343-      this.logger.error('❌ Conversation summary failed', error);
src/services/ai.ts-344-      return 'خطأ في إنتاج الملخص';
src/services/ai.ts-345-    }
--
src/services/ai.ts-440-  private buildProductRecommendationPrompt(
src/services/ai.ts-441-    customerQuery: string,
src/services/ai.ts-442-    context: ConversationContext,
src/services/ai.ts:443:    products: any[]
src/services/ai.ts-444-  ): OpenAI.Chat.Completions.ChatCompletionMessageParam[] {
src/services/ai.ts-445-    const productsText = products.map(p => 
src/services/ai.ts-446-      `ID: ${p.id}, SKU: ${p.sku}, اسم: ${p.name_ar}, سعر: $${p.price_usd}, فئة: ${p.category}`
--
src/services/ai.ts-501-        LIMIT 5
src/services/ai.ts-502-      `, [merchantId]);
src/services/ai.ts-503-
src/services/ai.ts:504:      return products.map((p: any) =>
src/services/ai.ts-505-        `${p.category}: ${p.count} منتج (متوسط السعر: ${Math.round(p.avg_price)})`
src/services/ai.ts-506-      ).join(', ');
src/services/ai.ts-507-    } catch (error) {
--
src/services/ai.ts-565-        Math.round(response.responseTime ?? 0),
src/services/ai.ts-566-        true
src/services/ai.ts-567-      ]);
src/services/ai.ts:568:    } catch (error: any) {
src/services/ai.ts-569-      this.logger.error('AI interaction logging failed:', {
src/services/ai.ts-570-        err: error?.message || String(error),
src/services/ai.ts-571-        stack: error?.stack,
--
src/tests/instagram-message-sender.test.ts-5-const tmpDir = path.join(process.cwd(), 'tmp-upload-tests');
src/tests/instagram-message-sender.test.ts-6-
src/tests/instagram-message-sender.test.ts-7-describe('InstagramAPIClient.uploadMedia', () => {
src/tests/instagram-message-sender.test.ts:8:  let client: any;
src/tests/instagram-message-sender.test.ts-9-
src/tests/instagram-message-sender.test.ts-10-  beforeEach(async () => {
src/tests/instagram-message-sender.test.ts-11-    mock.module('../services/telemetry.js', () => ({ telemetry: { recordMetaRequest: () => {} } }));
--
src/tests/instagram-message-sender.test.ts-38-    global.fetch = mock(async () => ({
src/tests/instagram-message-sender.test.ts-39-      ok: true,
src/tests/instagram-message-sender.test.ts-40-      json: async () => ({ id: 'media123' })
src/tests/instagram-message-sender.test.ts:41:    })) as any;
src/tests/instagram-message-sender.test.ts-42-
src/tests/instagram-message-sender.test.ts-43-    const id = await client.uploadMedia(filePath, 'image');
src/tests/instagram-message-sender.test.ts-44-    expect(id).toBe('media123');
--
src/tests/instagram-message-sender.test.ts-59-      ok: false,
src/tests/instagram-message-sender.test.ts-60-      text: async () => 'Bad Request',
src/tests/instagram-message-sender.test.ts-61-      statusText: 'Bad Request'
src/tests/instagram-message-sender.test.ts:62:    })) as any;
src/tests/instagram-message-sender.test.ts-63-
src/tests/instagram-message-sender.test.ts-64-    await expect(client.uploadMedia(filePath, 'image')).rejects.toThrow('Bad Request');
src/tests/instagram-message-sender.test.ts-65-  });
src/tests/instagram-message-sender.test.ts-66-});
src/tests/instagram-message-sender.test.ts-67-
src/tests/instagram-message-sender.test.ts-68-describe('InstagramMessageSender client caching', () => {
src/tests/instagram-message-sender.test.ts:69:  let sender: any;
src/tests/instagram-message-sender.test.ts:70:  let loadCredsMock: any;
src/tests/instagram-message-sender.test.ts-71-
src/tests/instagram-message-sender.test.ts-72-  beforeEach(async () => {
src/tests/instagram-message-sender.test.ts-73-    loadCredsMock = mock(async () => ({ tokenExpiresAt: new Date(Date.now() + 3600_000) }));
--
src/tests/instagram-message-sender.test.ts-113-});
src/tests/instagram-message-sender.test.ts-114-
src/tests/instagram-message-sender.test.ts-115-describe('InstagramMessageSender error logging', () => {
src/tests/instagram-message-sender.test.ts:116:  let sender: any;
src/tests/instagram-message-sender.test.ts:117:  let errorMock: any;
src/tests/instagram-message-sender.test.ts-118-
src/tests/instagram-message-sender.test.ts-119-  beforeEach(async () => {
src/tests/instagram-message-sender.test.ts-120-    errorMock = mock(() => {});
--
src/tests/instagram-message-sender.test.ts-122-    const client = {
src/tests/instagram-message-sender.test.ts-123-      loadMerchantCredentials: mock(async () => ({ token: 'x', tokenExpiresAt: new Date(Date.now() + 3600_000) })),
src/tests/instagram-message-sender.test.ts-124-      validateCredentials: mock(async () => {}),
src/tests/instagram-message-sender.test.ts:125:      sendMessage: mock(async (_cred: any, _merchant: string, { recipientId }: any) => {
src/tests/instagram-message-sender.test.ts-126-        if (recipientId === 'user2') {
src/tests/instagram-message-sender.test.ts-127-          return { success: false, error: 'fail' };
src/tests/instagram-message-sender.test.ts-128-        }
--
src/tests/instagram-message-sender.test.ts-144-    mock.module('../database/connection.js', () => ({ getDatabase: () => ({ getSQL: () => async () => [] }) }));
src/tests/instagram-message-sender.test.ts-145-    mock.module('../services/message-window.js', () => ({
src/tests/instagram-message-sender.test.ts-146-      getMessageWindowService: () => ({
src/tests/instagram-message-sender.test.ts:147:        getWindowStatus: mock(async (_merchantId: string, recipient: any) => {
src/tests/instagram-message-sender.test.ts-148-          if (recipient.instagram === 'user2') {
src/tests/instagram-message-sender.test.ts-149-            throw new Error('window fail');
src/tests/instagram-message-sender.test.ts-150-          }
--
src/tests/instagram-messaging.test.ts-12-    // @ts-ignore - setTimeout override for test
src/tests/instagram-messaging.test.ts-13-    globalThis.setTimeout = (cb: () => void, ms?: number) => {
src/tests/instagram-messaging.test.ts-14-      timers.push({ ms: ms || 0, cb });
src/tests/instagram-messaging.test.ts:15:      return 0 as any;
src/tests/instagram-messaging.test.ts-16-    };
src/tests/instagram-messaging.test.ts-17-
src/tests/instagram-messaging.test.ts-18-    // First call returns 429 (rate limit), second succeeds
--
src/tests/instagram-messaging.test.ts-43-    // @ts-ignore - setTimeout override for test
src/tests/instagram-messaging.test.ts-44-    globalThis.setTimeout = (cb: () => void, ms?: number) => {
src/tests/instagram-messaging.test.ts-45-      timers.push({ ms: ms || 0, cb });
src/tests/instagram-messaging.test.ts:46:      return 0 as any;
src/tests/instagram-messaging.test.ts-47-    };
src/tests/instagram-messaging.test.ts-48-
src/tests/instagram-messaging.test.ts-49-    // Always hit rate limit to exhaust retries
--
src/tests/instagram-media-manager.test.ts-37-  test('sends media using template', async () => {
src/tests/instagram-media-manager.test.ts-38-    const manager = new InstagramMediaManager();
src/tests/instagram-media-manager.test.ts-39-    try {
src/tests/instagram-media-manager.test.ts:40:      (manager as any).getMediaTemplate = async () => ({
src/tests/instagram-media-manager.test.ts-41-        id: 'temp1',
src/tests/instagram-media-manager.test.ts-42-        name: 'template',
src/tests/instagram-media-manager.test.ts-43-        category: 'promo',
--
src/tests/instagram-media-manager.test.ts-47-        usageCount: 0,
src/tests/instagram-media-manager.test.ts-48-        isActive: true
src/tests/instagram-media-manager.test.ts-49-      });
src/tests/instagram-media-manager.test.ts:50:      (manager as any).incrementTemplateUsage = async () => {};
src/tests/instagram-media-manager.test.ts:51:      (manager as any).generateTemplateCaption = () => 'generated caption';
src/tests/instagram-media-manager.test.ts-52-
src/tests/instagram-media-manager.test.ts-53-      const result = await manager.sendMediaMessage('user1', 'image', 'merchant1', 'temp1', undefined, undefined);
src/tests/instagram-media-manager.test.ts-54-      expect(result.success).toBe(true);
--
src/tests/media-id-uniqueness.test.ts-8-    const ids: string[] = [];
src/tests/media-id-uniqueness.test.ts-9-
src/tests/media-id-uniqueness.test.ts-10-    // Stub media manager to capture generated IDs without performing real processing
src/tests/media-id-uniqueness.test.ts:11:    (handler as any).mediaManager = {
src/tests/media-id-uniqueness.test.ts:12:      processIncomingMedia: async (media: any) => {
src/tests/media-id-uniqueness.test.ts-13-        ids.push(media.id);
src/tests/media-id-uniqueness.test.ts-14-        return { success: true };
src/tests/media-id-uniqueness.test.ts-15-      }
--
src/tests/media-id-uniqueness.test.ts-23-    const timestamp = new Date();
src/tests/media-id-uniqueness.test.ts-24-
src/tests/media-id-uniqueness.test.ts-25-    for (let i = 0; i < 20; i++) {
src/tests/media-id-uniqueness.test.ts:26:      await (handler as any).processMediaAttachment(
src/tests/media-id-uniqueness.test.ts-27-        attachment,
src/tests/media-id-uniqueness.test.ts-28-        conversationId,
src/tests/media-id-uniqueness.test.ts-29-        merchantId,
--
src/tests/instagram-token-retrieval.test.ts-30-    mock.module('../database/connection.js', () => ({
src/tests/instagram-token-retrieval.test.ts-31-      getDatabase: () => ({ getSQL: () => mock(async () => []) })
src/tests/instagram-token-retrieval.test.ts-32-    }));
src/tests/instagram-token-retrieval.test.ts:33:    (globalThis as any).requireMerchantId = () => 'merchant1';
src/tests/instagram-token-retrieval.test.ts-34-
src/tests/instagram-token-retrieval.test.ts-35-    const { getInstagramClient } = await import('../services/instagram-api.js');
src/tests/instagram-token-retrieval.test.ts-36-    const token = 'token123';
src/tests/instagram-token-retrieval.test.ts-37-    const encrypted = encryption.encryptInstagramToken(token);
src/tests/instagram-token-retrieval.test.ts-38-    const client = getInstagramClient('merchant1');
src/tests/instagram-token-retrieval.test.ts:39:    (client as any).db = { getSQL: () => mock(async () => [{
src/tests/instagram-token-retrieval.test.ts-40-      instagram_token_encrypted: encrypted,
src/tests/instagram-token-retrieval.test.ts-41-      instagram_page_id: 'page1',
src/tests/instagram-token-retrieval.test.ts-42-      webhook_verify_token: 'verify'
src/tests/instagram-token-retrieval.test.ts:43:    }]) } as any;
src/tests/instagram-token-retrieval.test.ts-44-
src/tests/instagram-token-retrieval.test.ts-45-    const fetchMock = mock(async () => ({
src/tests/instagram-token-retrieval.test.ts-46-      ok: true,
--
src/tests/instagram-token-retrieval.test.ts-48-      headers: { get: () => null },
src/tests/instagram-token-retrieval.test.ts-49-      json: async () => ({ id: 'biz1' })
src/tests/instagram-token-retrieval.test.ts-50-    }));
src/tests/instagram-token-retrieval.test.ts:51:    (globalThis as any).fetch = fetchMock;
src/tests/instagram-token-retrieval.test.ts-52-
src/tests/instagram-token-retrieval.test.ts-53-    const creds = await client.loadMerchantCredentials('merchant1');
src/tests/instagram-token-retrieval.test.ts-54-    expect(creds?.pageAccessToken).toBe(token);
--
src/tests/instagram-token-retrieval.test.ts-70-      instagram_token_encrypted: encrypted,
src/tests/instagram-token-retrieval.test.ts-71-      token_expires_at: new Date(Date.now() + 3600 * 1000)
src/tests/instagram-token-retrieval.test.ts-72-    }]);
src/tests/instagram-token-retrieval.test.ts:73:    (service as any).db = { getSQL: () => sqlMock } as any;
src/tests/instagram-token-retrieval.test.ts-74-
src/tests/instagram-token-retrieval.test.ts:75:    (service as any).getMerchantInstagramUserId = async () => 'ig_user_1';
src/tests/instagram-token-retrieval.test.ts:76:    (service as any).getMessageContext = async () => ({ conversationId: '', withinWindow: true });
src/tests/instagram-token-retrieval.test.ts:77:    (service as any).logSentMessage = async () => {};
src/tests/instagram-token-retrieval.test.ts:78:    (service as any).logFailedMessage = async () => {};
src/tests/instagram-token-retrieval.test.ts-79-
src/tests/instagram-token-retrieval.test.ts:80:    const fetchMock = mock(async (_url: string, options: any) => {
src/tests/instagram-token-retrieval.test.ts-81-      expect(options.headers.Authorization).toBe(`Bearer ${token}`);
src/tests/instagram-token-retrieval.test.ts:82:      return { ok: true, json: async () => ({ message_id: 'mid1' }) } as any;
src/tests/instagram-token-retrieval.test.ts-83-    });
src/tests/instagram-token-retrieval.test.ts:84:    (globalThis as any).fetch = fetchMock;
src/tests/instagram-token-retrieval.test.ts-85-
src/tests/instagram-token-retrieval.test.ts-86-    const res = await service.sendTextMessage('merchant1', 'recipient1', 'hello');
src/tests/instagram-token-retrieval.test.ts-87-    expect(res.success).toBe(true);
--
src/tests/instagram-webhook.test.ts-3-// Tests for processMessagingEvent
src/tests/instagram-webhook.test.ts-4-
src/tests/instagram-webhook.test.ts-5-describe('InstagramWebhookHandler.processMessagingEvent', () => {
src/tests/instagram-webhook.test.ts:6:  let handler: any;
src/tests/instagram-webhook.test.ts:7:  let logger: any;
src/tests/instagram-webhook.test.ts-8-
src/tests/instagram-webhook.test.ts-9-  beforeEach(async () => {
src/tests/instagram-webhook.test.ts-10-    logger = { info: mock(() => {}), error: mock(() => {}), warn: mock(() => {}) };
--
src/tests/instagram-webhook.test.ts-13-      createLogger: () => logger,
src/tests/instagram-webhook.test.ts-14-      getLogger: () => logger
src/tests/instagram-webhook.test.ts-15-    }));
src/tests/instagram-webhook.test.ts:16:    (globalThis as any).createLogger = () => logger;
src/tests/instagram-webhook.test.ts-17-    mock.module('../services/instagram-api.js', () => ({ getInstagramClient: () => ({}) }));
src/tests/instagram-webhook.test.ts-18-    mock.module('../database/connection.js', () => ({ getDatabase: () => ({ getSQL: () => async () => [] }) }));
src/tests/instagram-webhook.test.ts-19-    mock.module('../repositories/index.js', () => ({ getRepositories: () => ({}) }));
--
src/tests/instagram-webhook.test.ts-27-    const mod = await import('../services/instagram-webhook.ts');
src/tests/instagram-webhook.test.ts-28-    handler = new mod.InstagramWebhookHandler();
src/tests/instagram-webhook.test.ts-29-
src/tests/instagram-webhook.test.ts:30:    (handler as any).findOrCreateConversation = mock(async () => ({ id: 'conv1', isNew: false }));
src/tests/instagram-webhook.test.ts:31:    (handler as any).storeIncomingMessage = mock(async () => {});
src/tests/instagram-webhook.test.ts:32:    (handler as any).generateAIResponse = mock(async () => {});
src/tests/instagram-webhook.test.ts-33-  });
src/tests/instagram-webhook.test.ts-34-
src/tests/instagram-webhook.test.ts-35-  afterEach(() => {
src/tests/instagram-webhook.test.ts-36-    mock.restore();
src/tests/instagram-webhook.test.ts:37:    delete (globalThis as any).createLogger;
src/tests/instagram-webhook.test.ts-38-  });
src/tests/instagram-webhook.test.ts-39-
src/tests/instagram-webhook.test.ts-40-  test('handles message successfully', async () => {
--
src/tests/instagram-webhook.test.ts-46-    };
src/tests/instagram-webhook.test.ts-47-    const result = { success: true, eventsProcessed: 0, conversationsCreated: 0, messagesProcessed: 0, errors: [] };
src/tests/instagram-webhook.test.ts-48-
src/tests/instagram-webhook.test.ts:49:    const ret = await (handler as any).processMessagingEvent(event, 'merchant1', result);
src/tests/instagram-webhook.test.ts-50-
src/tests/instagram-webhook.test.ts-51-    expect(ret).toBe(1);
src/tests/instagram-webhook.test.ts-52-    expect(result.messagesProcessed).toBe(1);
--
src/tests/instagram-webhook.test.ts-54-  });
src/tests/instagram-webhook.test.ts-55-
src/tests/instagram-webhook.test.ts-56-  test('logs error when conversation creation fails', async () => {
src/tests/instagram-webhook.test.ts:57:    (handler as any).findOrCreateConversation = mock(async () => null);
src/tests/instagram-webhook.test.ts-58-
src/tests/instagram-webhook.test.ts-59-    const event = {
src/tests/instagram-webhook.test.ts-60-      sender: { id: 'user1' },
--
src/tests/instagram-webhook.test.ts-63-      message: { mid: 'm1', text: 'hello' }
src/tests/instagram-webhook.test.ts-64-    };
src/tests/instagram-webhook.test.ts-65-    const result = { success: true, eventsProcessed: 0, conversationsCreated: 0, messagesProcessed: 0, errors: [] };
src/tests/instagram-webhook.test.ts:66:    await expect((handler as any).processMessagingEvent(event, 'merchant1', result)).rejects.toThrow('Failed to create conversation');
src/tests/instagram-webhook.test.ts-67-    expect(logger.error.mock.calls.length).toBeGreaterThan(0);
src/tests/instagram-webhook.test.ts-68-  });
src/tests/instagram-webhook.test.ts-69-});
--
src/tests/instagram-webhook.test.ts-71-// Tests for inviteCommentToDM
src/tests/instagram-webhook.test.ts-72-
src/tests/instagram-webhook.test.ts-73-describe('InstagramWebhookHandler.inviteCommentToDM', () => {
src/tests/instagram-webhook.test.ts:74:  let handler: any;
src/tests/instagram-webhook.test.ts:75:  let logger: any;
src/tests/instagram-webhook.test.ts:76:  let client: any;
src/tests/instagram-webhook.test.ts-77-
src/tests/instagram-webhook.test.ts-78-  beforeEach(async () => {
src/tests/instagram-webhook.test.ts-79-    logger = { info: mock(() => {}), error: mock(() => {}) };
--
src/tests/instagram-webhook.test.ts-87-      createLogger: () => logger,
src/tests/instagram-webhook.test.ts-88-      getLogger: () => logger
src/tests/instagram-webhook.test.ts-89-    }));
src/tests/instagram-webhook.test.ts:90:    (globalThis as any).createLogger = () => logger;
src/tests/instagram-webhook.test.ts-91-    mock.module('../services/instagram-api.js', () => ({ getInstagramClient: () => client }));
src/tests/instagram-webhook.test.ts-92-    mock.module('../database/connection.js', () => ({ getDatabase: () => ({ getSQL: () => async () => [] }) }));
src/tests/instagram-webhook.test.ts-93-    mock.module('../repositories/index.js', () => ({ getRepositories: () => ({}) }));
--
src/tests/instagram-webhook.test.ts-104-
src/tests/instagram-webhook.test.ts-105-  afterEach(() => {
src/tests/instagram-webhook.test.ts-106-    mock.restore();
src/tests/instagram-webhook.test.ts:107:    delete (globalThis as any).createLogger;
src/tests/instagram-webhook.test.ts-108-  });
src/tests/instagram-webhook.test.ts-109-
src/tests/instagram-webhook.test.ts-110-  test('sends DM invitation successfully', async () => {
src/tests/instagram-webhook.test.ts:111:    await (handler as any).inviteCommentToDM('merchant1', 'comment1', 'user1');
src/tests/instagram-webhook.test.ts-112-    expect(client.replyToComment.mock.calls.length).toBe(1);
src/tests/instagram-webhook.test.ts-113-    expect(logger.info.mock.calls[0][0]).toBe('DM invitation sent');
src/tests/instagram-webhook.test.ts-114-  });
src/tests/instagram-webhook.test.ts-115-
src/tests/instagram-webhook.test.ts-116-  test('logs error if reply fails', async () => {
src/tests/instagram-webhook.test.ts-117-    client.replyToComment = mock(async () => { throw new Error('fail'); });
src/tests/instagram-webhook.test.ts:118:    await (handler as any).inviteCommentToDM('merchant1', 'comment1', 'user1');
src/tests/instagram-webhook.test.ts-119-    expect(logger.error.mock.calls.length).toBe(1);
src/tests/instagram-webhook.test.ts-120-  });
src/tests/instagram-webhook.test.ts-121-});
--
src/tests/oauth-session-pkce.test.ts-45-
src/tests/oauth-session-pkce.test.ts-46-// In-memory session store to simulate database
src/tests/oauth-session-pkce.test.ts-47-const sessions: Record<string, any> = {};
src/tests/oauth-session-pkce.test.ts:48:const sql = async (strings: TemplateStringsArray, ...values: any[]) => {
src/tests/oauth-session-pkce.test.ts-49-  const query = strings.join(' ');
src/tests/oauth-session-pkce.test.ts-50-  if (query.includes('INSERT INTO oauth_sessions')) {
src/tests/oauth-session-pkce.test.ts-51-    const [merchantId, state, codeVerifier, codeChallenge, redirectUri] = values;
--
src/tests/oauth-session-pkce.test.ts-96-
src/tests/oauth-session-pkce.test.ts-97-afterEach(() => {
src/tests/oauth-session-pkce.test.ts-98-  mock.restore();
src/tests/oauth-session-pkce.test.ts:99:  delete (global as any).fetch;
src/tests/oauth-session-pkce.test.ts-100-});
src/tests/oauth-session-pkce.test.ts-101-
src/tests/oauth-session-pkce.test.ts-102-describe('OAuth session PKCE handling', () => {
--
src/tests/oauth-session-pkce.test.ts-126-
src/tests/oauth-session-pkce.test.ts-127-  test('exchanges code with PKCE verifier', async () => {
src/tests/oauth-session-pkce.test.ts-128-    const service = new InstagramOAuthService();
src/tests/oauth-session-pkce.test.ts:129:    (service as any).exchangeForLongLivedToken = mock(async () => ({
src/tests/oauth-session-pkce.test.ts-130-      access_token: 'long',
src/tests/oauth-session-pkce.test.ts-131-      token_type: 'bearer',
src/tests/oauth-session-pkce.test.ts-132-      expires_in: 3600
--
src/tests/oauth-session-pkce.test.ts-134-    const codeVerifier = 'another_verifier';
src/tests/oauth-session-pkce.test.ts-135-    let requestBody = '';
src/tests/oauth-session-pkce.test.ts-136-
src/tests/oauth-session-pkce.test.ts:137:    (global as any).fetch = mock(async (url: any, options: any) => {
src/tests/oauth-session-pkce.test.ts-138-      if (url === 'https://api.instagram.com/oauth/access_token') {
src/tests/oauth-session-pkce.test.ts-139-        requestBody = options.body;
src/tests/oauth-session-pkce.test.ts-140-        return {
src/tests/oauth-session-pkce.test.ts-141-          ok: true,
src/tests/oauth-session-pkce.test.ts-142-          json: async () => ({ access_token: 'short', user_id: 123 })
src/tests/oauth-session-pkce.test.ts:143:        } as any;
src/tests/oauth-session-pkce.test.ts-144-      }
src/tests/oauth-session-pkce.test.ts:145:      return { ok: false, text: async () => '', status: 500 } as any;
src/tests/oauth-session-pkce.test.ts-146-    });
src/tests/oauth-session-pkce.test.ts-147-
src/tests/oauth-session-pkce.test.ts-148-    await service.exchangeCodeForToken('code123', 'merchant1', codeVerifier);
--
src/routes/webhooks.ts-48-/**
src/routes/webhooks.ts-49- * Extract merchant ID from Instagram webhook by looking up Page ID
src/routes/webhooks.ts-50- */
src/routes/webhooks.ts:51:async function extractMerchantId(webhookEvent: any): Promise<string> {
src/routes/webhooks.ts-52-  try {
src/routes/webhooks.ts-53-    // Get the first entry's Instagram Business Account ID
src/routes/webhooks.ts-54-    if (webhookEvent.entry && webhookEvent.entry.length > 0) {
--
src/routes/webhooks.ts-81-    });
src/routes/webhooks.ts-82-    
src/routes/webhooks.ts-83-    return 'default-merchant-id';
src/routes/webhooks.ts:84:  } catch (error: any) {
src/routes/webhooks.ts-85-    log.error('Error extracting merchant ID:', error);
src/routes/webhooks.ts-86-    return 'default-merchant-id';
src/routes/webhooks.ts-87-  }
--
src/routes/webhooks.ts-124-
src/routes/webhooks.ts-125-      log.info('Instagram webhook verification successful', { challenge });
src/routes/webhooks.ts-126-      return c.text(challenge);
src/routes/webhooks.ts:127:    } catch (error: any) {
src/routes/webhooks.ts-128-      log.error('Instagram webhook verification error:', error);
src/routes/webhooks.ts-129-      return c.text('Internal Server Error', 500);
src/routes/webhooks.ts-130-    }
--
src/routes/webhooks.ts-134-  app.post('/webhooks/instagram', async (c) => {
src/routes/webhooks.ts-135-    try {
src/routes/webhooks.ts-136-      // Get raw body for HMAC verification
src/routes/webhooks.ts:137:      const rawBody = (c as any).rawBody;
src/routes/webhooks.ts-138-      if (!rawBody) {
src/routes/webhooks.ts-139-        log.error('No raw body available for HMAC verification');
src/routes/webhooks.ts-140-        return c.text('Bad Request - Raw body required', 400);
--
src/routes/webhooks.ts-234-        // Fast response (target: < 150ms)
src/routes/webhooks.ts-235-        return c.text('OK', 200);
src/routes/webhooks.ts-236-        
src/routes/webhooks.ts:237:      } catch (enqueueError: any) {
src/routes/webhooks.ts-238-        const processingTime = Date.now() - requestStartTime;
src/routes/webhooks.ts-239-        
src/routes/webhooks.ts-240-        log.error('Failed to enqueue Instagram webhook', {
--
src/routes/webhooks.ts-246-        telemetry.recordMetaRequest('instagram', 'webhook', 500, processingTime, false);
src/routes/webhooks.ts-247-        return c.text('Service Temporarily Unavailable', 503);
src/routes/webhooks.ts-248-      }
src/routes/webhooks.ts:249:    } catch (error: any) {
src/routes/webhooks.ts-250-      log.error('Instagram webhook processing error:', error);
src/routes/webhooks.ts-251-      
src/routes/webhooks.ts-252-      // Push to dead letter queue for retry
--
src/routes/webhooks.ts-259-            timestamp: new Date().toISOString()
src/routes/webhooks.ts-260-          }
src/routes/webhooks.ts-261-        }));
src/routes/webhooks.ts:262:      } catch (dlqError: any) {
src/routes/webhooks.ts-263-        log.error('Failed to push to DLQ:', dlqError);
src/routes/webhooks.ts-264-      }
src/routes/webhooks.ts-265-
--
src/routes/webhooks.ts-313-          .digest('hex');
src/routes/webhooks.ts-314-
src/routes/webhooks.ts-315-        return c.text(`sha256=${exp}`);
src/routes/webhooks.ts:316:      } catch (error: any) {
src/routes/webhooks.ts-317-        log.error('Debug endpoint error:', error);
src/routes/webhooks.ts-318-        return c.text('Error', 500);
src/routes/webhooks.ts-319-      }
--
src/routes/webhooks.ts-346-      expected: `sha256=${expected}`,
src/routes/webhooks.ts-347-      bodyLength: rawBody.length
src/routes/webhooks.ts-348-    });
src/routes/webhooks.ts:349:  } catch (error: any) {
src/routes/webhooks.ts-350-    log.error('Failed to log Instagram event:', error);
src/routes/webhooks.ts-351-  }
src/routes/webhooks.ts-352-}
--
src/routes/admin.ts-31-    try {
src/routes/admin.ts-32-      const snapshot = getHealthSnapshot();
src/routes/admin.ts-33-      return c.json(snapshot, snapshot.ready ? 200 : 503);
src/routes/admin.ts:34:    } catch (error: any) {
src/routes/admin.ts-35-      log.error('Health endpoint error:', error);
src/routes/admin.ts-36-      return c.json({
src/routes/admin.ts-37-        ready: false,
--
src/routes/admin.ts-51-        ready: isReady,
src/routes/admin.ts-52-        timestamp: new Date().toISOString()
src/routes/admin.ts-53-      }, isReady ? 200 : 503);
src/routes/admin.ts:54:    } catch (error: any) {
src/routes/admin.ts-55-      log.error('Readiness endpoint error:', error);
src/routes/admin.ts-56-      return c.json({ ready: false, error: error.message }, 503);
src/routes/admin.ts-57-    }
--
src/routes/admin.ts-62-    try {
src/routes/admin.ts-63-      const snapshot = getHealthSnapshot();
src/routes/admin.ts-64-      return c.json(snapshot, snapshot.ready ? 200 : 503);
src/routes/admin.ts:65:    } catch (error: any) {
src/routes/admin.ts-66-      log.error('Healthz endpoint error:', error);
src/routes/admin.ts-67-      return c.json({
src/routes/admin.ts-68-        ready: false,
--
src/routes/admin.ts-96-      };
src/routes/admin.ts-97-
src/routes/admin.ts-98-      return c.json(metrics);
src/routes/admin.ts:99:    } catch (error: any) {
src/routes/admin.ts-100-      log.error('Metrics endpoint error:', error);
src/routes/admin.ts-101-      return c.json({ error: error.message }, 500);
src/routes/admin.ts-102-    }
--
src/routes/admin.ts-126-      } finally {
src/routes/admin.ts-127-        client.release();
src/routes/admin.ts-128-      }
src/routes/admin.ts:129:    } catch (error: any) {
src/routes/admin.ts-130-      log.error('Stats endpoint error:', error);
src/routes/admin.ts-131-      return c.json({ error: error.message }, 500);
src/routes/admin.ts-132-    }
--
src/routes/admin.ts-155-      };
src/routes/admin.ts-156-
src/routes/admin.ts-157-      return c.json(queueStats);
src/routes/admin.ts:158:    } catch (error: any) {
src/routes/admin.ts-159-      log.error('Queue stats endpoint error:', error);
src/routes/admin.ts-160-      return c.json({ error: error.message }, 500);
src/routes/admin.ts-161-    }
--
src/routes/admin.ts-197-          decryptionMatch: success
src/routes/admin.ts-198-        }
src/routes/admin.ts-199-      });
src/routes/admin.ts:200:    } catch (error: any) {
src/routes/admin.ts-201-      log.error('Encryption validation error:', error);
src/routes/admin.ts-202-      return c.json({
src/routes/admin.ts-203-        test: 'encryption_validation',
--
src/routes/admin.ts-225-      } finally {
src/routes/admin.ts-226-        client.release();
src/routes/admin.ts-227-      }
src/routes/admin.ts:228:    } catch (error: any) {
src/routes/admin.ts-229-      log.error('Database validation error:', error);
src/routes/admin.ts-230-      return c.json({
src/routes/admin.ts-231-        test: 'database_validation',
--
src/routes/admin.ts-249-        queueReady: !!getQueueManager(),
src/routes/admin.ts-250-        timestamp: new Date().toISOString()
src/routes/admin.ts-251-      });
src/routes/admin.ts:252:    } catch (error: any) {
src/routes/admin.ts-253-      log.error('Redis validation error:', error);
src/routes/admin.ts-254-      return c.json({
src/routes/admin.ts-255-        test: 'redis_validation',
--
src/routes/admin.ts-286-        app_id: appId,
src/routes/admin.ts-287-        timestamp: new Date().toISOString()
src/routes/admin.ts-288-      });
src/routes/admin.ts:289:    } catch (error: any) {
src/routes/admin.ts-290-      log.error('Meta API ping error:', error);
src/routes/admin.ts-291-      return c.json({
src/routes/admin.ts-292-        test: 'meta_api_ping',
--
src/routes/utility-messages.ts-104-          timestamp: result.timestamp.toISOString()
src/routes/utility-messages.ts-105-        }, 400);
src/routes/utility-messages.ts-106-      }
src/routes/utility-messages.ts:107:    } catch (error: any) {
src/routes/utility-messages.ts-108-      log.error('Send utility message error:', error);
src/routes/utility-messages.ts-109-      return c.json({
src/routes/utility-messages.ts-110-        success: false,
--
src/routes/utility-messages.ts-160-        status: 'created',
src/routes/utility-messages.ts-161-        timestamp: new Date().toISOString()
src/routes/utility-messages.ts-162-      });
src/routes/utility-messages.ts:163:    } catch (error: any) {
src/routes/utility-messages.ts-164-      log.error('Create template error:', error);
src/routes/utility-messages.ts-165-      return c.json({
src/routes/utility-messages.ts-166-        success: false,
--
src/routes/utility-messages.ts-197-        count: templates.length,
src/routes/utility-messages.ts-198-        timestamp: new Date().toISOString()
src/routes/utility-messages.ts-199-      });
src/routes/utility-messages.ts:200:    } catch (error: any) {
src/routes/utility-messages.ts-201-      log.error('Get templates error:', error);
src/routes/utility-messages.ts-202-      return c.json({
src/routes/utility-messages.ts-203-        success: false,
--
src/routes/utility-messages.ts-237-        hasMore: messages.length === limit,
src/routes/utility-messages.ts-238-        timestamp: new Date().toISOString()
src/routes/utility-messages.ts-239-      });
src/routes/utility-messages.ts:240:    } catch (error: any) {
src/routes/utility-messages.ts-241-      log.error('Get message history error:', error);
src/routes/utility-messages.ts-242-      return c.json({
src/routes/utility-messages.ts-243-        success: false,
--
src/routes/utility-messages.ts-262-        },
src/routes/utility-messages.ts-263-        timestamp: new Date().toISOString()
src/routes/utility-messages.ts-264-      });
src/routes/utility-messages.ts:265:    } catch (error: any) {
src/routes/utility-messages.ts-266-      log.error('Utility messages health check error:', error);
src/routes/utility-messages.ts-267-      return c.json({
src/routes/utility-messages.ts-268-        status: 'degraded',
--
src/tests/meta-rate-limiter.test.ts-53-describe('MetaRateLimiter', () => {
src/tests/meta-rate-limiter.test.ts-54-  test('generates unique members for successive zadd operations', async () => {
src/tests/meta-rate-limiter.test.ts-55-    const limiter = new MetaRateLimiter();
src/tests/meta-rate-limiter.test.ts:56:    (limiter as any).redis = new FakeRedisManager();
src/tests/meta-rate-limiter.test.ts-57-
src/tests/meta-rate-limiter.test.ts-58-    const key = 'test';
src/tests/meta-rate-limiter.test.ts-59-    const windowMs = 1000;
--
src/tests/meta-rate-limiter.test.ts-62-    await limiter.checkRedisRateLimit(key, windowMs, max);
src/tests/meta-rate-limiter.test.ts-63-    await limiter.checkRedisRateLimit(key, windowMs, max);
src/tests/meta-rate-limiter.test.ts-64-
src/tests/meta-rate-limiter.test.ts:65:    const store = (limiter as any).redis.connection.store as Map<string, Set<string>>;
src/tests/meta-rate-limiter.test.ts-66-    const firstKey = Array.from(store.keys())[0];
src/tests/meta-rate-limiter.test.ts-67-    const members = Array.from(store.get(firstKey) ?? []);
src/tests/meta-rate-limiter.test.ts-68-
